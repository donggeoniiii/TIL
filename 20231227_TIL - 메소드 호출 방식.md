# 20231227_TIL - 메소드 호출 방식

## 메소드 호출 방식

메소드가 호출되면 메모리의 stack 상에 그 함수를 위한 별도 공간이 생성되고, 종료시 사라진다. 거기에 필요한 매개변수와 지역변수, 반환값이 저장되게 된다. 여기서 매개변수와 지역변수를 가져오는 방식에는 두 가지 방식이 있다.

### call-by-value

메소드 호출 시 전달되는 변수값을 복사해서 가져온다. 이 때 그 값을 담은 매개변수는 그 값을 복사한 객체와 다른 객체다.

해당 메소드에서만 지역적으로 사용하기 때문에, 마찬가지로 메소드 종료 후 사라진다.

```java
ex)

static void print(int n) {
    n = 20;
    System.out.print(n + " ");
}

public static void main(String[] args) {
    int n = 10;
    print(n);
    System.out.println(n);
}

// output: 20 10
```

### call-by-reference

메소드 호출 시 인자로 전달되는 변수의 reference를 전달한다. 따라서 함수 안에서 인자의 값이 바뀌면, 매개변수로 전달되는 객체의 값도 바뀐다.

```java
ex)

void print(int *n) {
    *n = 20;
    printf("%d ", n);
}

void main() {
    int n = 10;
    print(n);
    printf("%d", n);
}

// output: 20 20
```

예시에서 볼 수 있는 것처럼, Java는 오직 call-by-value 방식으로 값을 넘긴다. C나 C++에서는 두 가지 경우 모두 가능하다. 사실 Java는 변수의 reference 자체를 넘길 수가 없다.

참조형 자료형을 넘기는 경우에는 메모리 상에서 보관하는 영역이 다르므로(값은 heap, 객체 정보 자체는 stack) 해당하는 객체의 주소값을 `복사` 하는 방식으로 사용한다. 마찬가지로, 이 주소값을 가지고 있는 객체는 처음에 생성된 원본 객체와 다르다.

```java
ex)

class Person {
    private String name;

    public Person(String name) {
            this.name = name;
    }
}

public static void main(String[] args) {
    Person a = new Person("donggeon");

    rename(a);
}

void rename(Person b) {
    c = new Person("icebear");
}
```

.. 쓰다보니 당연해 보이지만, 정리해보자면

1) 첫 Person 클래스의 인스턴스 a가 생성된다.

2) b는 a의 주소값만 복사해서 갖고 있다. 참조하는 값은 `donggeon`이다.

3) c는 `icebear`라는 이름을 가지는 완전히 다른 인스턴스이다. 주소값도 a, b와 아예 다르고, 당연히 이름도 다르다.

### Java와 C/C++의 변수 할당 방식의 차이점

Java에서 매개변수에 주소를 복사해서 보내는 것을 call-by-reference라고 착각할 수 있지만, 이는 C나 C++에서 사용하는 변수 할당 방식과 차이가 비교해보면 아닌 것을 알 수 있다.

Java의 경우에도 변수가 만들어지면 새로운 메모리 공간을 부여받긴 하지만, 이 공간에는 값 자체가 아니라 그 값으로 향하는 주소값이 저장된다. 즉, 이 변수가 가지고 있는 `값`은 `할당된 값의 위치(주소)`이고, 매개변수에는 이 `값`이 전달되는 것이므로 `call-by-value`에 해당한다고 말하는 것이 옳다.

C/C++은 기본적으로 변수가 선언될 때 메모리 공간을 할당하고, 여기에 값을 계속 덮어씌우는 방식으로 값을 할당한다. 그렇기 때문에 `call-by-reference` 방식으로 주소를 인자로 넘기면 내부에서 값을 덮어 씌울 때 해당 주소에서 가리키는 값이 바뀌게 된다. 

### 그럼 Java에서 deep copy를 어떻게 할 수 있을까?

찾아본 결과, 객체에 대해 `Object.clone()`이라는 메소드가 있다. 말 그대로 메소드를 긁어오는 과정인데, 이 메소드를 오버라이드 해서 실제 값을 변경하게 하는 방법이 있는 것 같다. 하지만 이 방법은 대부분의 경우에 권장되지 않는 것으로 보인다(final이 붙은 불변클래스 정도)

주로 사용하는 방식은 클론팩토리와 생성자를 사용하는 것..인데, 결국 우리가 배열을 복사할 때 새로운 인스턴스를 만들어 새롭게 값을 저장하는 것과 비슷한 방식이다. 

요약하자면, 새로운 인스턴스를 만들어서 변경할 값을 입력하고, 이 인스턴스의 값을 기존에 값을 변경하려고 한 객체에 재할당하는 수밖에 없다.

### 장단점

`call-by-value`의 경우 원본 데이터가 변경될 일이 없어서 안정적이다. 다만 위에서 Java의 예시에서 알 수 있는 것처럼 값이 변경될 때마다 새로운 객체를 생성해서 값을 할당하기 위한 공간을 만들어야 하므로 메모리 부담이 상대적으로 크다.

`call-by-reference`의 경우 정확히 반대이다. 추가적인 메모리 소모는 일어나지 않지만 원본 값이 변경될 수도 있는 위험성이 존재한다.