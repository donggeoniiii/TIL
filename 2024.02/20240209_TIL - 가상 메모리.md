# 20240209_TIL - 가상 메모리

## 페이징을 통한 가상 메모리 관리

앞서 배운 연속 메모리 할당 방식은 외부 단편화라는 큰 문제를 가진다. 그리고 근본적으로 물리적인 메모리 용량 이상의 프로세스는 실행이 불가능하다. 

`가상 메모리`는 실행하려는 프로그램의 일부분만 메모리에 적재해 실제 물리 메모리 용량보다 큰 프로세스를 실행하게 만드는 기술이다. 관리하는 기법에는 `페이징`과 `세그멘테이션`이 있고 현대 대부분의 운영체제는 페이징 기법을 사용한다. 페이징을 사용하면 외부 단편화 문제도 해결할 수 있다.

### 페이징(paging)

만약 프로세스와 메모리를 일정한 단위로 자르고, 메모리에 불연속적으로 할당할 수 있다고 하자. 그러면 연속 메모리 할당에서 경험했던 외부 단편화를 예방할 수 있다. 

이렇게 프로세스의 논리 주소 공간을 `페이지`라는 일정한 단위로 자르고, 메모리 물리 주소 공간을 `프레임`이라는 동일한 크기 단위로 자른 뒤 페이지를 프레임에 할당하는 방식을 `페이징` 기법이라고 한다.

페이징의 장점은 여기서도 스와핑을 적용시킬 수 있다는 점이다. 이때는 프로세스 단위로 스왑을 진행하는 것이 아니라 페이지 단위로 스왑이 가능하다. 여기서는 `페이지 인 - 페이지 아웃`이라고 표현한다. 

하지만 프로그램이 불연속적으로 메모리에 할당되면 CPU 입장에서는 다음에 어떤 명령어를 실행해야 할지 알기가 어렵다. 

### 페이지 테이블

페이지 테이블은 페이징 시스템에서 프로세스의 명령어들이 연속적인 논리 주소를 배치받도록 하는 방식이다. 페이지 번호와 프레임 번호를 짝지어주는 이정표 역할을 한다. 

페이지 테이블은 어떤 페이지(논리 주소)가 어떤 프레임(물리 주소)에 들어 있는지 알려준다. 따라서 CPU는 페이지 번호만 알면 해당 페이지가 적재된 프레임을 찾을 수 있다. CPU의 입장에선 그저 연속된 논리 주소대로 명령어를 실행할 뿐이다.

프로세스는 각자의 페이지 테이블을 가지고 있고, 페이지 테이블 역시 프로세스가 실행될 때 메모리에 적재된다. 그리고 `페이지 테이블 베이스 레지스터(PTBR)`가 CPU 내에서 실행 중인 프로세스의 페이지 테이블 주소를 가리키고 있다. 

### TLB

페이지 테이블이 메모리에 있고 이를 참조한다고 생각하면, CPU는 하나의 명령어를 실행하기 위해 2번의 메모리 참조가 필요하게 된다(페이지 테이블 한 번, 명령어가 있는 프레임 한 번). 

여기서 성능 개선을 위해 페이지 테이블 역시 `TLB(Translation Lookaside Buffer)`라는 캐시 메모리를 둔다. TLB는 페이지 테이블의 일부를 저장한다. 일반적으로 논리 주소를 물리 주소로 변경하는 MMU(Memory Management Unit) 옆에 있다.

CPU는 메모리를 거치기 전에 TLB에서 찾는 프레임 번호가 있는지 확인하고, 있는 경우 즉시 해당 주소로 방문한다. 이를 `TLB 히트`라고 한다(like 캐시 히트).

### 내부 단편화

페이징은 프로세스를 나누어 탑재하는 방식으로 외부 단편화 문제를 해결하지만, 이 과정에서 프로세스의 크기가 일정한 페이지 크기로 딱 맞게 나누어지지 않는 경우 `내부 단편화` 문제가 발생할 수 있다. 한 페이지의 크기가 모든 프로세스의 배수일 수는 없으므로, 이 문제는 필연적으로 발생한다.

이를 방지하기 위해서는 최소한 페이지의 크기를 조절해 페이지 내부에 생기는 빈 공간을 줄이거나, 리눅스 등 운영체제에서 사용하는 것처럼 기본 페이지보다 더 큰 페이지 크기를 허용하여 메모리에 싣는 방식이 필요하다.

### 페이징에서의 주소 변환

페이징 시스템에서는 모든 주소가 페이지 번호와 변위로 이루어진다. 페이지 번호는 곧 실제로 메모리에 탑재된 프레임으로 이어지고, 변위를 이용해 프레임의 시작 주소에서 얼마나 떨어진 명령어인지 알 수 있다. 프레임과 페이지의 크기가 같으므로 변위값은 바뀌지 않는다.

### 페이지 테이블 엔트리

페이지 테이블의 각 행, `페이지 테이블 엔트리(Page Table Entry, PTE)`에는 페이지 번호와 프레임 번호 외에도 많은 정보가 있다. 

- `유효 비트`
    
    현재 해당 페이지에 접근 가능한지를 알려준다. 페이징 기법에서도 스와핑이 일어나기 때문에, 가져오려는 정보가 보조기억장치에 있을 수도 있다. 유효 비트는 페이지가 메모리에 있어 접근 가능하면 1, 보조기억장치에 있으면 0이 된다.
    
    만약 0인 비트에 접근하려고 하면 `페이지 폴트(page fault)`라는 예외가 발생한다. 예외 역시 인터럽트의 일종이므로 처리하는 과정은 우리가 하는 바와 같다. ISR에서는 해당 페이지를 메모리로 페이지 인을 하고 유효 비트를 1로 바꿔준다.
    
- `보호 비트`
    
    페이지 보호 기능을 위한 비트. 2가지 버전이 있다.
    
    - binary: 0이면 읽기만, 1이면 쓰기도 가능한 페이지다. 프로세스에서 코드 영역 같은 읽기 전용 영역을 보호한다.
    - ternary: r이면 읽기 권한, w면 쓰기 권한, x면 실행 권한을 나타낸다. 예를 들어 `100`인 비트는 r이 1, w가 0, x가 0인 보호비트다.
- `참조 비트`
    
    메모리에 적재된 후 CPU가 읽거나 쓴 페이지를 1로 표현한다.
    
- `수정 비트`
    
    페이지의 변경 여부를 0과 1로 표현한다. 페이지 아웃이 일어났을 때 보조기억장치에 변경 사항을 써야 하는지 판단하게 해준다. `더티 비트(dirty bit)`라고도 한다.
    

실제 페이지 테이블 엔트리에는 이 밖에도 다양한 정보가 있다.

### 쓰기 시 복사

페이징은 외부 단편화 문제를 해결할 뿐만 아니라 프로세스 간에 페이지를 공유할 수 있다는 장점이 있다. 대표적인 예시가 `쓰기 시 복사(copy on write)` 기능이다.

프로세스를 fork해서 부모 프로세스를 복제한 자식 프로세스를 만들 때, 같은 내용을 담은 프레임이 메모리 상에 2배가 되는 것은 불필요한 작업이다. 

`쓰기 시 복사` 기능에서는 자식 프로세스의 페이징 테이블도 부모 프로세스와 동일한 프레임을 가리키게 된다. 이는 코드 영역 같이 복제할 필요 없는 부분에 대해 불필요한 복사 작업을 막을 수 있다. 이는 쓰기가 일어나기 전까지 유지된다.

만약 여기서 자식 프로세스 상에서 쓰기 작업이 일어나면, 부모 프로세스와 자식 프로세스의 내용이 달라졌으므로 해당 페이지 내용이 별도의 메모리 공간으로 복제된다. 그리고 페이징 테이블에서 복제된 프레임을 가리키게 된다. 

쓰기 시 복사를 이용하면 프로세스 생성 시 불필요한 복사 작업으로 인한 생성 시간을 줄일 수도 있고, 메모리 공간도 절약이 가능하다.

### 계층적 페이징

페이지 테이블은 생각보다 크다. 그렇기 때문에 모든 PTE를 메모리에 탑재하는 것은 큰 메모리 낭비로 이어진다. 

`계층적 페이징`은 페이지 테이블 역시 페이징하여 여러 단계의 페이지를 두는 방식이다. 폴더 구조를 생각하면 되겠다. 이런 계층적 구조를 이용하면 모든 페이지 테이블을 항상 메모리에 유지할 필요가 없다.

계층적 페이지를 이용하게 된다면 CPU가 가지고 있는 논리 주소 형태도 바뀌게 된다. 페이지 번호가 여러 개가 필요하므로 `바깥 페이지 번호 + 안쪽 페이지 번호 + 변위` 형태를 가진다. 

계층적 구조는 여러 겹일 수 있다. 단 이 경우 페이지 폴트가 발생했을 때 그만큼 메모리 참조 횟수가 많아지므로(가져와야 하는 테이블이 많아지니까) 계층이 많은 것이 좋은 것만은 아니다.
