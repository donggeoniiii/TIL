# 20240410_TIL - 소프트웨어 아키텍처, 객체 지향

## 소프트웨어 아키텍처

소프트웨어를 구성하는 요소들 간의 관계를 표현하는 구조(체).

### 소프트웨어 아키텍처 설계의 기본 원리

- `모듈화`
    
    시스템의 기능을 모듈 단위로 분해한다. 모듈 내 응집도는 높이고 모듈 간 결합도는 낮춰 성능, 재사용성 및 유지보수성을 올린다.
    
- `추상화`
    - `과정 추상화`
        
        각 과정을 상세히 기술하지 않고 시스템의 전체적인 흐름만 파악할 수 있게 표시한다.
        
    - `자료 추상화`
        
        데이터들을 대표적으로 나타내는 표현으로 나타낸다.
        
        ex) 일정 생성 시 연, 월, 일을 입력한다. → 일정 생성 시 `날짜`를 입력한다.
        
    - `제어 추상화`
        
        이벤트를 처리하는 정확한 절차나 방법이 아니라 이를 대표하는 표현으로 대체한다.
        
        ex) 윤년이면 364일로 나누고, 윤년이 아니면 365일로 표시한다. → 윤년인지 확인한다.
        
- `단계적 분해`
    
    문제를 상위의 큰 개념에서 하위 개념으로 분할해 나가며 구체화한다.
    
- `정보 은닉`
    
    한 모듈 내부의 절차나 자료의 정보가 숨겨져 다른 모듈이 접근하거나 변경하지 못하게 한다.
    

### 협약에 의한 설계

컴포넌트를 설계할 때 클래스에 대한 가정, 생각을 공유하도록 명세한 것(딴말 없기)

- `선행 조건`: 오퍼레이션이 실행되기 전 선행되어야 하는 조건(조건문 상에서 반드시 참)
- `결과 조건`: 오퍼레이션 수행 후 만족되어야 하는 조건
- `불변 조건`: 오퍼레이션 실행 시 만족되어야 하는 조건

### 아키텍처 패턴

- `레이어 패턴`
    
    시스템이 계층화되어 있다. 
    
    상위 계층은 하위 계층의 서비스 이용자(클라이언트)가 되고, 하위 계층은 서비스 제공자가 된다. 마주보는 두 계층 사이에서만 상호작용이 일어난다.
    
    ex) OSI 참조 모델
    
- `클라이언트-서버 패턴`
    
    여러 개의 클라이언트와 하나의 서버가 존재한다. 
    
    사용자는 클라이언트를 통해 요청을 보내고 클라이언트는 서버와 통신해 서버의 응답을 사용자에게 제공한다.
    
- `파이프-필터 패턴`
    
    데이터 처리 시 각 스트림을 필터로 캡슐화하고, 이 필터를 모아 파이프라이닝해 전송한다.
    
    ex) UNIX의 Shell, 데이터 변환, 버퍼링, 동기화 등
    
- `MVC 패턴`
    - `Model`
        
        시스템의 주요 기능과 데이터를 갖고 있다. 컨트롤러를 타고 온 사용자의 요청에 따라 연산을 수행한다.
        
    - `View`
        
        모델이 수행한 연산 결과를 출력한다.
        
    - `Controller`
        
        사용자의 요청을 처리해 모델에게 알맞은 연산을 요청한다.
        
- `마스터-슬레이브 패턴`
    
    마스터가 시킨 일을 슬레이브 컴포넌트가 수행하면 결과물을 마스터가 돌려받는다.
    
    ex) 병렬 컴퓨팅 시스템(하나의 주인님과 여러 명의 노예), 장애 허용 시스템
    
- `브로커 패턴`
    
    사용자가 원하는 서비스와 특성을 브로커 컴포넌트에게 요청하면 브로커가 요청에 맞는 컴포넌트와 사용자를 매칭해준다. 
    
    ex) 분산 환경 시스템
    
- `피어-투-피어 패턴`
    
    하나의 컴포넌트가 서버가 될 수도 있고, 클라이언트가 될 수 있다. 서버와 클라이언트 역할을 하는 두 컴포넌트가 한 쌍으로 작동한다.
    
    ex) 파일 공유 네트워크(aka p2p)
    
- `이벤트-버스 패턴`
    
    Source가 이벤트 메시지를 특정 채널에 Publish하면, 구독한 Listener들이 메시지를 받아 이벤트를 처리한다.
    
    ex) 알림 서비스(Kafka)
    
- `블랙보드 패턴`
    
    모든 컴포넌트가 공유하는 데이터 저장소가 있고 블랙보드 컴포넌트를 사용한다.
    
    ex) 음성 인식, 차량 식별, 신호 해석
    
- `인터프리터 패턴`
    
    프로그램 코드의 각 라인을 수행하는 방법을 지정하고, 기호마다 클래스를 갖도록 구성되어 있다.
    
    ex) 번역기, 인터프리터 및 컴파일러
    
<br>

## 객체 지향(Object-oriented)

소프트웨어의 각 요소들을 `객체(Object)`로 만들고 이를 조립해 소프트웨어를 개발하는 기법.

### 객체 지향의 구성 요소

- `객체`
    
    데이터와 이를 처리하기 위한 함수를 묶어 놓은 소프트웨어 모듈
    
    - `데이터(필드)`: 객체가 가지고 있는 속성, 상태(bool, enum 등), 분류 등
    - `함수(메소드)`: 객체가 갖고 있는 데이터를 참조해서 수행하는 기능.
- `클래스`
    
    공통된 속성과 연산을 가지고 있는 객체들의 집합. 
    
    이때 특정 클래스에 속하는 객체를 그 클래스의 `인스턴스`라고 한다.
    
- `메시지`
    
    객체들 간의 상호작용에 사용되는 수단. 객체의 동작이나 연산을 일으키는 외부로부터의 요구사항이다.
    
    객체는 이에 대응하는 연산(메소드)을 수행해서 결과를 반환한다.
    

### 객체 지향의 특징

- `캡슐화`
    
    외부에서의 접근을 인터페이스를 통해서로만 제한한다. 이를 통해 객체의 세부 내용을 은닉한다.
    
    객체 간에 메시지를 주고 받으면서 서로의 상세 정보를 알 필요가 없어지므로 결합도가 감소하는 효과가 있다.
    
- `추상화`
    
    현실 세계에 존재하는 대상의 본질적인 특징을 추출해서 가상세계의 객체로서 정의한다.
    
    ```java
    ex) 사람
    class Person {
    	int age;
    	String gender;
    	String name;
    	LocalDate birthday;
    	String job;
    
    	// 취직/이직함
    	private getJob(String newJob) {
    		job = newJob;
    	}
    }
    ```
    
- `상속`
    
    상위 클래스의 모든 속성과 연산을 하위 클래스가 물려 받는다(재정의 필요 x).
    
    필요하다면 상위 클래스의 속성과 연산 외에 고유한 부분을 더 확장시킬 수 있다.
    
- `다형성`
    
    상속받은 클래스들은 하나의 메시지에 대해 각자의 고유한 방법으로 응답할 수 있다. 이때 클래스들은 동일한 메소드명을 사용한다. 
    
    Java에선 메소드 오버로딩 / 오버라이딩을 통해 구현된다.
    
    ex) + 연산: 숫자에선 덧셈(plus), 문자열 클래스에서는 연결(concat)
    

### 객체지향 설계 원칙(SOLID)

- `단일 책임 원칙(SRP)`
    
    객체는 단 하나의 책임만 가진다. 하나의 클래스가 여러 기능을 담당해선 안된다.
    
    ex) Person → 개발자, 사람 ⇒ Developer, Person으로 클래스 나누어 관련 기능 구분
    
- `개방-폐쇄 원칙(OCP)`
    
    기능을 추가할 수는 있지만, 기존의 코드를 변경하지 않으면서 되어야 한다.
    
    즉 확장엔 열려 있지만(Open), 변경엔 닫혀 있다(Close).
    
- `리스코프 치환 원칙(LSP)`
    
    자식 클래스는 최소한 부모 클래스의 기능은 수행할 수 있어야 한다.
    
    즉 부모 클래스가 하위 클래스의 인스턴스로 생성되어도 정상 작동해야 한다. 
    
- `인터페이스 분리 원칙(ISP)`
    
    인터페이스는 범용적이지 않는 편이 좋다. 그리고 사용하지 않는 인터페이스와는 영향을 받아선 안된다.
    
- `의존 역전 원칙(DIP)`
    
    추상화에 의존한다. 구체적으로 구현된 클래스보단 추상화된 클래스나 인터페이스와 의존관계를 맺는 편이 올바르다.
    

### 객체지향 분석

사용자의 요구사항을 객체, 속성, 연산, 관계 등으로 추상화해 정의하고 모델링한다.

소프트웨어를 개발하기 위한 비즈니스를 객체와 그 속의 속성 / 클래스와 그 하위 클래스 / 전체와 부분 등으로 나눈다.

### 객체지향 방법론

대체로 요건 정의 - 객체지향 분석 - 설계 및 구현 - 테스트의 절차를 거친다.

- `Booch 방법론`
    
    미시적 개발 프로세스와 거시적 개발 프로세스를 모두 사용한다. 요구사항 속 대상을 객체로 식별한 후 이를 토대로 하는 클래스의 속성과 연산을 정의한다. 
    
    디자인(= 모델 설계)에 초점을 둔다. 설계를 문서화하는 걸 강조하고 다이어그램 중심의 개발을 진행한다.
    
    분석과 설계가 구분되어 있지 않다.
    
- `Jacobson 방법론`
    
    유스케이스를 모든 모델의 근간으로 사용한다.
    
    분석 - 설계 - 구현 공정을 가지고 있고, 기능적 요구사항에 초점을 둔다.
    
- `Coad-Yourdon 방법론`
    
    ERD를 통해 객체의 행위를 모델링한다.
    
    객체 식별 - 구조 식별 - 주제 정의 - 속성과 인스턴스 연결 정의 - 연산과 메시지 연결 정의 순으로 이어진다.
    
- `Wilfs-Brock 방법론`
    
    분석과 설계 사이 구분이 없다. 고객 명세서를 평가해 설계 작업까지 연속적으로 수행한다.
    
- `Rumbaugh 방법론`

### Rumbaugh 방법론

분석 활동을 객체 모델/동적 모델/기능 모델로 나누어 수행한다. 

`객체 모델링 기법(Object Modeling Technique, OMT)`으로 부르기도 한다.

1. `객체 모델링` 
    
    시스템의 정적 구조를 표현한다. 정보 모델링이라고도 한다. 
    
    시스템에서 사용될 객체를 요구사항을 바탕으로 식별하고, 객체의 속성과 연산 그리고 다른 객체들과의 관계를 규정한다.
    
    산출물로 객체 다이어그램이 나온다.
    
2. `동적 모델링`
    
    시간의 흐름에 따른 객체들 간의 제어 흐름, 상호작용, 동작 순서 등의 동적 행위를 규정한다.
    
    산출물로 상태 다이어그램이 나온다.
    
3. `기능 모델링`
    
    다수의 프로세스 간의 데이터 흐름을 중심으로 처리 과정을 표현한다.
    
    산출물로 자료 흐름도(DFD)가 나온다.