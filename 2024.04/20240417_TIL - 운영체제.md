# 20240417_TIL - 운영체제

## 운영체제

CPU, RAM 등의 컴퓨터 자원을 효율적으로 관리하고 편리하고 효과적으로 사용하게 해주는 프로그램

### 운영체제의 목적

- `처리능력 향상`: 일정 시간 내 시스템이 처리하는 일의 양
- `반환 시간 단축`: 작업을 의뢰한 시간부터 처리가 완료되기까지
- `사용 가능도 향상`: 시스템을 사용해야 할 때 즉시 사용 가능한 정도
- `신뢰도 향상`: 시스템이 주어진 문제를 정확하게 해결 가능한지

### 대표적인 언어

- `UNIX`
    
    1960년대 만들어졌다. 시분할 시스템을 위해 설계되었다.
    
    비교적 low level 언어인 C언어로 만들어져 있어 장치나 프로세스 간의 호환성이 좋다.
    
    - `커널`
        
        운영체제와 하드웨어 사이에 인터페이스 역할을 한다. 운영체제의 핵심 기능이 담겨 있다.
        
    - `쉘`
        
        사용자의 명령어를 인식해서 프로그램을 호출하고 명령을 수행하는 명령어 해석기. 시스템과 사용자 간의 인터페이스가 된다.
        
- `LINUX`
    
    1991년 리누스 토르발스에 의해 만들어졌다. UNIX 기반이다.
    
    대부분의 특징이 UNIX와 동일하며 오픈소스 소프트웨어로 프로그래머가 원하는 기능을 무료로 추가할 수 있다.
    
- `Android`
    
    구글에서 개발한 리눅스 커널 기반의 개방형 모바일 운영체제다.
    
    오픈 소스이고, 자바와 코틀린으로 어플리케이션 코드를 작성한다.
    
- `Windows`
    
    설명 생략
    

(참고)

- `Secure OS`
    
    기존 운영체제에 보안기능을 가진 커널을 이식한다. 
    
    외부의 침입으로부터 시스템 자원을 보호한다.
    

### UNIX / LINUX 주요 명령어

- `fork` 새로운 프로세스 생성
- `mkdir` 디렉터리 생성
- `cd` 동일 드라이브 내에서 디렉터리 변경, 뒤에 점만 찍으면 상위 디렉터리로 이동
- `chmod` 파일의 보호모드 생성해 파일의 사용 허가를 지정
    - `chmod (소유자 권한) (그룹 권한) (기타 사용자 권한) (파일 이름)`
        
        권한은 각각 `r(읽기)`, `w(쓰기)`, `x(실행)`에 대해 권한 여부를 표시하고, 권한이 있으면 1, 없으면 0으로 표기해 3자리의 2진수 표현으로 나타낸다.
        
<br>

## 가상기억장치를 이용한 메모리 관리

### 기억장치 관리 - 배치 전략

새로 실행할 프로그램이나 데이터가 주기억장치에 어디에 위치시킬 지를 결정한다.

- `최초 적합`: 처음으로 보이는 빈 자리에 앉기
- `최적 적합`: 가장 딱 들어가는 자리에 앉기
- `최악 적합`: 가장 널널한 자리에 앉기

### 가상기억장치

가상 기억장치, `가상 메모리`는 보조기억장치의 일부를 주기억장치로 활용해 용량이 작은 주기억장치를 마치 큰 용량을 가진 것처럼 사용한다.

- `페이징 기법`
    
    프로그램과 주기억장치의 영역을 물리적으로 동일한 크기로 나누어 필요한만큼 적재한다.
    
    프로그램을 일정한 크기로 나눈 것을 `페이지`, 주기억장치를 일정한 크기로 나눈 것을 `프레임`이라고 한다.
    
- `세그멘테이션 기법`
    
    가상기억장치에 보관되어 있는 프로그램을 배열이나 함수 등의 논리적인 단위로 나눈 후 주기억장치에 적재시켜 실행시킨다.
    
    이때 프로그램이 나눠진 논리적인 단위를 `세그먼트`라고 한다. 세그먼트는 각각 고유한 이름과 크기를 갖는다.
    

### 페이지 부재

프로그램 실행 중 필요한 내용이 들어있는 페이지가 메모리에 올라와 있지 않으면 `페이지 부재(Page Fault)`라고 한다. 

만약 페이지 부재가 너무 자주 발생하면, 프로세스 처리 시간보다 페이지 교체에 더 많은 시간이 소요되는 `스래싱(Thrashing)` 현상이 발생한다.

이를 방지하기 위해 프로세스의 `지역성(Locality)`성질을 이용해 자주 사용하는 페이지들의 집합인 `워킹 셋(Working Set)`을 사용한다. 

### 페이지 교체 알고리즘

만약 새로운 페이지를 올릴 공간이 없을 때, 기존에 있던 페이지 중 어떤 페이지를 내리고 새로운 페이지를 올릴 지 결정하는 방법을 `페이지 교체 알고리즘`이라고 한다.

알고리즘이 얼마나 적합한지는 페이지 부재 발생 정도로 따진다. 적을수록 좋다. 

- `OPT(Optimal replacement)`
    
    앞으로 가장 오래 사용하지 않을 페이지를 내린다. 가장 효율적이지만 구현이 어렵다.
    
- `FIFO(First In First Out)`
    
    가장 먼저 올라온 순서대로 내린다.
    
- `LRU(Least Recently Used)`
    
    가장 오랫동안 사용되지 않은 페이지부터 내린다.
    
- `LFU(Least Frequently Used)`
    
    가장 사용 빈도가 적은 페이지를 교체한다.
    

### RAID(Redundant Array of Independant Disk)

2개 이상의 하드 디스크로 디스크 배열을 구성하고, 파일을 구성하는 데이터 블록을 서로 다른 디스크에 분산 저장하거나 다중화한다.

구현된 기술에 따라 레벨로 구분한다.

- `RAID 0 - 스트라이핑`
    
    디스크를 병렬로 연결해 디스크 개수만큼 용량과 속도가 증가한다. 
    
    하나가 고장나면 전체 데이터가 파손된다.
    
- `RAID 1 - 미러링`
    
    같은 데이터를 다른 디스크에 동일하게 복사한다.
    
- `RAID 2~4`
    
    하나의 디스크에 오류 정정 부호를 저장한다.
    
    저장하는 단위에 따라 레벨을 구분한다.
    
    - `RAID 2 - bit`
    - `RAID 3 - byte`
    - `RAID 4 - 단어`
    
    나머지 디스크는 병렬로 연결해 RAID 0처럼 사용한다.
    
    하나의 디스크가 고장나도 정상 가동이 되지만 적어도 3개의 디스크가 필요하다.
    
- `RAID 5`
    
    오류 정정 부호를 블록 단위로 여러 디스크에 분산 저장한다.
    
    하나의 디스크가 고장나도 정상 가동이 되지만 적어도 3개의 디스크가 필요하다.
    
- `RAID 6`
    
    `RAID 5`와 원리는 비슷하나 오류 정정 부호를 2개 저장한다. 
    
    디스크가 2개까지 고장나도 정상 가동이 되지만 적어도 4개의 디스크가 필요하다.

<br>

## 프로세스

프로세서(CPU)에 의해 실행되고 있는 사용자 혹은 시스템 프로그램.

- `PCB를 가지고 있는가?`
- `실기억장치에 저장되어 있는가?`
- `디스패치(실행 상태로 전환)가 가능한가?`
- `프로시저가 활동 중인가?`
- `비동기적 행위를 일으키는 주체인가?`
- `운영체제가 관리하고 있는가?`

이에 해당하면 프로세스다.

### PCB(Process Control Block)

프로세스 제어 블록. 운영체제가 프로세스에 대한 중요한 정보를 저장한다.

- 고유 식별자
- 프로세스 상태
- 포인터
- 레지스터 정보
- 주기억장치 관리 정보
- 입출력 상태 정보
- 계정 정보

### 프로세스 상태 전이

- `준비`: 스케줄러에 의해 준비 Queue에 올라가 있는 상태
- `실행`: 준비 Queue에서 디스패치(프로세서에 할당)되어 메모리에 올라간 상태
- `대기`: 입/출력 이벤트 발생으로 처리되기까지 기다리는 상태(실행 중 아님)
    - `wake-up`: 입/출력 이벤트가 끝나 다시 실행되기 위해 준비 Queue로 이동
    - `스풀링`
        
        입/출력할 데이터를 바로 입출력장치로 보내지 않고 한꺼번에 입출력하기 위해 디스크에 저장해둔다.
        
        입출력장치의 상대적으로 느린 처리 속도를 보완하기 위함이다.
        

### 스레드

시스템의 여러 자원을 할당받아 실행하는 프로그램의 단위. 프로세스 내에서의 작업 단위로 사용된다. 경량 프로세스라고도 한다.

<br>

## CPU 스케줄링

프로세스에게 시스템 자원을 할당하는 작업. CPU는 동시에 여러 프로세스에 할당될 수 없으므로 적절한 방식을 선택해야 한다.

### 비선점 스케줄링

이미 할당된 CPU는 다른 프로세스가 강제로 빼앗아 사용할 수 없다.

일괄처리 방식에 주로 사용된다.

- `FCFS(First Come First Service)`
    
    준비 Queue에 들어온 순서에 따라 CPU를 할당한다. 앞에 프로세스가 종료되어야 그 다음 프로세스가 할당된다.
    
- `SJF(Shortest Job First)`
    
    준비 Queue에 있는 프로세스 중 실행 시간이 가장 짧은 프로세스가 가장 먼저 할당된다.
    
    가장 적은 평균 대기시간을 제공하는 최적 알고리즘이다.
    
- `HRN(Highest Response-ratio Next)`
    
    대기 시간과 실행 시간을 이용해 우선순위를 계산한다.  
    
    식은 `(대기 시간) + (실행 시간) / (실행 시간)`. 값이 가장 큰 프로세스부터 실행된다.
    
- 그외 `우선순위`, `기한부` 등

### 선점 스케줄링

한 프로세스가 실행되고 있을 때 우선순위가 높은 다른 프로세스가 CPU 자원을 강제로 빼앗아 사용할 수 있다.

주로 빠른 응답 시간을 요구하는 대화식 시분할 시스템에 사용된다.

- `RR(Round Robin)`
    
    프로세스별로 시간 할당량 동안만 실행한 후 다음 프로세스에게 CPU를 넘겨준다.
    
    시분할 시스템을 위해 고안되었다. 할당되는 시간의 크기가 작으면 작은 프로세스에게 유리하다.
    
    할당되는 시간이 클 경우 FCFS 기법과 같아지고(그냥 종료돼서 자연스럽게 턴 넘어감), 너무 작으면 문맥 교환이 너무 자주 일어난다. 그래서 적절한 시간을 주는 게 중요하다.
    
- `SRT(Shortest Remaining Time)`
    
    현재 실행 중인 프로세스의 남은 시간과 준비 Queue에 새로 도착한 프로세스의 실행 시간을 비교하여 가장 짧은 실행 시간을 요구하는 프로세스에게 CPU를 할당한다.
    
    시분할 시스템에 자주 사용된다.
    
    준비 Queue에 있는 모든 프로세스의 잔여 실행 시간을 추적해야 하므로 오버헤드가 증가한다.

<br>

## 교착 상태(데드 락)

둘 이상의 프로세스가 하나의 공유 자원을 점유한 상태, 서로 다른 프로세스의 공유 자원을 요구하며 무한정 기다리는 현상. 

### 발생 원인(데드락의 필요충분조건)

- `상호 배제`
    
    한 번에 한 개의 프로세스만 공유 자원을 이용하게 되다보면 데드락이 발생할 수 있다.
    
- `점유와 대기`
    
    작동을 위해 하나의 자원을 계속 점유한 상태에서 다른 자원을 요청하고 있으면 데드락이 발생할 수 있다.
    
- `비선점`
    
    다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗지 않으면 데드락이 발생할 수 있다.
    
- `환형 대기`
    
    하나의 자원을 점유한 상태에서 서로 꼬리에 꼬리를 물고 옆 프로세스의 자원을 요청하게 되면 데드락이 발생할 수 있다.
    

### 해결 방법

- `예방`
    
    사전에 시스템을 제어해 데드락이 일어나지 않게 한다. 위의 발생 원인 중 하나를 제거하면 데드락은 발생하지 않는다.
    
    다만 이 경우 자원 분배에 이상 현상을 가져올 수도 있다.
    
- `회피`
    
    데드락이 발생할 가능성을 배제하지 않는다. 대신 발생하면 적절히 피해나간다.
    
    `은행원 알고리즘`이 여기서 사용된다.
    
- `발견`
    
    시스템에 데드락이 발생했는지 점검해서 데드락 상태의 프로세스와 자원을 발견한다.
    
- `회복`
    
    데드락을 일으킨 프로세스를 종료하거나 할당된 자원을 다른 프로세스에 선점시켜 상태를 회복시킨다.