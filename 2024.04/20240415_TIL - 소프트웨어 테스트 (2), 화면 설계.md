# 20240415_TIL - 소프트웨어 테스트 (2), 화면 설계

## 개발 단계에 따른 어플리케이션 테스트

- 요구사항 → `인수 테스트(Acceptance Test)`
- 분석 → `시스템 테스트`
- 설계 → `통합 테스트(Integration Test)`
- 코드 → `단위 테스트(Unit Test)`

순서는 V자로 진행된다.

### 인수 테스트

개발한 소프트웨어가 사용자의 요구사항을 잘 충족하는지 확인한다.

- `알파 테스트`
    - 개발자의 장소에서 사용자가 개발자 앞에서 테스트한다.
    - 통제된 환경에서 시행
    - 오류나 사용상 문제점을 사용자와 개발자가 함께 확인한다.
- `베타 테스트`
    - 선정된 최종 사용자가 사용자들 앞에서 테스트한다.
        - 그 ‘베타 테스트’ 맞다.
    - 실업무를 가지고 직접 테스트해본다.

### 시스템 테스트

개발된 소프트웨어가 해당 컴퓨터 시스템에서 잘 작동하는지 확인한다.

### 통합 테스트

단위 테스트가 종료된 모듈을 결합해 하나의 시스템으로 완성시키는 과정에서 진행한다.

- `비점진적 통합 방식`
    - 단계적 통합 절차 없이 모든 모듈이 이미 결합되어 있는 프로그램 전체를 테스트한다.
    - 빅뱅 통합 테스트 방식
- `점진적 통합 방식`
    - 모듈 단위로 단계적 통합하며 테스트한다.
    - 하향식/상향식/혼합식 통합 테스트

### 통합 테스트 - 하향식

탑-다운 방식. 상위 모듈에서 하위 모듈 방향으로 통합하며 테스트한다.

1. 주요 제어 모듈을 제외한 부가적인 종속 모듈들은 `스텁`으로 대체한다.
2. 깊이 우선 또는 넓이 우선으로 통합 방식을 정한다.
3. 모듈이 통합될 때마다 스텁이었던 모듈들이 하나씩 실제 모듈이 된다.
4. 새로운 오류가 발생하지 않음을 보증하기 위해 회귀 테스트를 진행한다.

### 통합 테스트 - 상향식

바텀-업 방식. 하위 모듈에서 상위 모듈 방향으로 통합하며 테스트한다.

1. 하위 모듈들을 `클러스터`로 결합한다.
2. 상위 모듈의 입출력 데이터를 확인하기 위해 더미 모듈인 `드라이버`를 사용한다.
3. 클러스터 단위로 테스트 한다.
4. 테스트가 완료되면 클러스터는 상위 구조로 이동해 결합한다.
드라이버는 실제 모듈로 대체된다.

### 회귀 테스트

이미 테스트된 프로그램의 테스팅을 반복한다. 

통합 테스트로 수정한 모듈이나 컴포넌트가 다른 부분에 영향을 미치거나 오류가 생기지 않았음을 보증하기 위해 진행한다.

### 단위 테스트

최소 단위인 모듈, 컴포넌트에 초점을 맞춰 테스트한다.

- 인터페이스, 외부 입출력, 자료구조, 오류 처리 경로, 독립적 기초 경로, 경계 조건 등
- 사용자의 요구사항에 맞는지 확인하는 기능성 테스트를 최우선 진행한다.
- 구조 기반 테스트와 명세 기반 테스트로 나뉘지만 주로 구조 기반 테스트를 시행한다.

<br>

## 기타 테스트 용어

### 테스트 오라클

테스트 결과가 올바른지 판단하기 위해 사전에 정의된 값들을 이용하는 방법.

- `참 오라클`
    
    모든 테스트 케이스에 대해 True가 되는 값을 넣는다. 
    
    틀린 경우는 오류라는 거니까 발생하는 모든 오류 검출이 가능하다.
    
- `샘플링 오라클`
    
    특정 테스트 케이스의 입력값들에 대해서만 기대하는 결과를 제공한다.
    
    전체에 대한 테스트가 불가능한 경우 사용한다.
    
- `추정 오라클`
    
    특정 테스트 케이스만 기대하는 결과를 제공하고 나머지는 추정값을 넣는다.
    
- `일관성 검사 오라클`
    
    어플리케이션에 변경이 있을 때 변경 전, 후의 결과값이 동일한지를 확인한다.
    

### 테스트 성능 처리 지표

- `처리량(Throughput)`: 단위 시간당 어플리케이션의 처리하는 일량
- `응답 시간(Response Time)`: 어플리케이션에 요청 전달 후 응답 도착까지 걸리는 시간
- `경과 시간(Turn Around Time)`: 어플리케이션에 작업을 의뢰하고 처리 완료까지 걸린 시간
- `자원 사용률(Resource Usage)`: 어플리케이션의 작업 처리시간 동안 CPU 사용량, 메모리 사용량, 네트워크 사용량 등

### 테스트 자동화 도구

- `정적 분석 도구`
    
    프로그램을 실행하지 않고 분석한다. 코딩 컨벤션, 스타일, 복잡도를 체크한다.
    
- `테스트 실행 도구`
    
    테스트 데이터와 수행방법이 포함된 스크립트를 작성하고 테스트를 실행한다. 
    
- `성능 테스트 도구`
    
    가상의 사용자 데이터로 테스트를 진행해 자원 사용률, 처리량, 응답 시간, 경과 시간 등 성능적인 목표 달성 여부를 확인한다.
    
- `테스트 통제 도구`
    
    테스트 계획 및 관리, 테스트 수행, 결함 관리 등을 수행하는 도구다.
    
- `테스트 하네스 도구`
    
    테스트가 실행될 환경을 가상으로 제공해 컴포넌트나 모듈이 잘 작동하는지 확인시켜주는 도구들이다.
    
    - `드라이버(Driver)`: 하위 모듈 호출, 파라미터 전달, 수행 결과 출력
    - `스텁(Stub)`: 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행
    - `테스트 케이스`
        
        사용자 요구사항을 잘 준수했는지 확인하기 위한 테스트 명세서
        
        - 입력값
        - 실행 조건
        - 기대 결과 등
    - `슈트(Suit)`: 테스트 대상 컴포넌트나 모듈, 시스템에 사용되는 테케의 집합
    - `테스트 스크립트`: 자용화된 테스트 실행 절차에 대한 명세서
    - `목(mock) 오브젝트`: 사전에 사용자의 행위를 조건부로 입력하면 그 상황에 맞는 행위를 수행

<br>

## 소스 코드 검사

### 순환 복잡도

한 프로그램의 논리적 복잡도를 측정하기 위한 소프트웨어의 척도. `맥케이브 순환도`라고도 한다.

제어 흐름도의 영역 수와 동일하다.

1. 영역 수 구하기
2. (정점) - (간선) + 2

### 소스 코드 최적화

- `클린 코드`: 누구나 쉽게 이해할 수 있다. 단순 명료하다.
- `나쁜 코드`: 로직이 복잡하고 이해하기 어렵다.
    - `스파게티 코드`: 코드의 로직이 서로 복잡하게 꼬임
    - `외계인 코드`: 아주 오래되어 참고 문서나 작성한 개발자가 없음, 유지보수 어려움

### 클린코드 작성 원칙

- `가독성`: 누구나 읽기 쉬운 용어나 들여쓰기 등으로 표현한다.
- `단순성`: 한 번에 한 가지를 처리하도록 코드의 기능을 최소 단위로 분리한다.
- `의존성 배제`: 코드가 다른 모듈에 미치는 영향을 최소화한다.
- `중복성 최소화`
- `추상화`: 상위 레벨에서는 간략하게 특성만 나타내고, 구현은 하위 레벨에서

### 소스 코드 품질 분석 도구

- `정적 분석 도구`
  - 소스코드 실행 없이 코딩 컨벤션, 결함 등을 확인한다.
  - pmd, cppcheck, SonarQube, checkstyle, ccm, cobertrua 등
- `동적 분석 도구`
  - 소스코드를 실행해 메모리 누수나 스레드 결함을 확인한다.
  - Avalanche, Valgrind 등

<br>

## 화면 설계

### UI와 UX

- `UI`는 사용자와 시스템의 상호작용이 잘 일어나도록 돕는다.
    - 정보 전달을 위한 물리적 제어
    - 컨텐츠의 상세적 표현이나 전체적인 구성
    - 모든 사용자가 편하고 간편하게 사용하도록 하는 기능
- `UX`는 사용자가 시스템이나 서비스를 이용하며 느끼고 생각하는 총체적인 경험이다.

 UI는 사용성, 접근성, 편리성 중심, UX는 UI를 통한 사용자의 만족과 감정 중심

### UI의 종류

- `CLI(Command Line Interface)`: 명령과 출력이 텍스트
- `GUI(Graphic User Interface)`: 그래픽 환경, 아이콘을 마우스로 선택해 수행
- `NUI(Natural User Interface)`: 사용자의 말, 행동 등 움직임으로 기기를 조작

### UI의 기본 원칙

- `직관성`: 누구나 쉽게 이해하고 사용할 수 있어야 한다.
- `유효성`: 사용자의 목적을 정확히 수행해야 한다.
- `학습성`: 누구나 쉽게 배우고 익힐 수 있어야 한다.
- `유연성`: 사용자의 요구사항을 최대한 수용하고 실수를 최소화한다.