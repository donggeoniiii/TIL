# 20240405_TIL - 소프트웨어 구조 (2)

## UML

### 유스케이스 다이어그램

사용자가 개발될 프로그램으로 수행할 수 있는 기능을 표현

- `시스템 범위`
    
    유스케이스들을 사각형으로 묶어 시스템의 범위를 표현
    
- `액터`
    
    시스템과 상호작용하는 모든 외부 요소
    
    - `주액터`: 보통 사용자
    - `부액터`: 사용자의 목적 달성을 위해 시스템에 서비스를 제공하는 외부 시스템
- `유스케이스`
    
    사용자의 관점에서 시스템이 제공하는 서비스와 기능을 표현한 것
    
- `관계`
    - `포함(Include)`
        
        여러 개의 유스케이스가 공통 적용되는 기능을 별도로 분리해 새로운 유스케이스로 만드는 경우.
        
    - `확장(Extend)`
        
        유스케이스가 특정 조건에 부합해 유스케이스의 기능이 확장되는 경우.
        

### 클래스 다이어그램

클래스와 클래스가 가지는 속성, 클래스 사이의 관계를 표현한다.

- `클래스`
    
    각 객체들이 갖는 속성과 동작을 표현
    
    - `속성`: 클래스의 상태나 정보
    - `오퍼레이션`: 클래스가 수행할 수 있는 동작, aka 함수(메소드)
- `제약조건`
    
    속성에 입력될 값의 조건 혹은 오퍼레이션 수행 전후 지정해줘야 하는 조건 등. 클래스 안에 쓸 때는 중괄호 안에 표시한다
    
- `관계`
    
    클래스와 클래스 사이 연관성. 연관 관계, 집합 관계, 포함 관계, 일반화 관계, 의존 관계.
    

### 순차 다이어그램

시스템이나 객체가 메시지를 주고 받으며 상호작용하는 과정을 그림으로 표현한다.

- `액터`: 시스템으로부터 서비스를 요청하는 외부 요소
- `객체`: 메시지를 주고 받는 객체
- `생명선`: 객체가 메모리에 존재하는 기간. 점선으로 표시
- `실행 상자`: 객체가 메시지를 주고 받으며 구동되고 있음을 알려준다.
- `메시지`: 객체가 상호작용을 위해 주고받는 메시지
- `객체 소멸`: 생명선이 끝나는 지점
- `프레임`: 다이어그램의 전체 혹은 일부를 묶어 표현한다.

### 패키지 다이어그램

유스케이스나 클래스 등의 요소를 그룹화한 패키지 간의 의존 관계를 표시한다.

- `패키지`: 객체를 그룹화한 것
    - `단순 표기법`: 패키지 이름만 표현
    - `확장 표기법`: 요소까지 표현
- `객체`: 패키지 안에 포함될 수 있는 요소들. 유스케이스, 클래스, 인터페이스, 테이블 등
- `의존 관계`: 스테레오타입(<<>>)으로 표현
    - `import`: 패키지에 포함된 객체들을 직접 가져와 이용하는 관계
    - `export`: 인터페이스를 통해 패키지 내의 객체에 접근해 이용하는 관계

<br>

## 소프트웨어 개발 방법론

### 컴포넌트 기반 방법론

기존의 시스템이나 소프트웨어를 구성하는 컴포넌트를 조합해 새 어플리케이션을 만든다. 재사용하는 만큼 시간이나 노력이 덜 든다.

- 개발 준비 → 분석 → 설계 → 구현 → 테스트 → 전개 → 인도

참고로 재사용의 종류는 2가지가 있다.

- `합성 중심`: 소프트웨어 부품을 블록처럼 끼워 맞춰 완성, 블록 구성 방법
- `생성 중심`: 추상화된 명세서를 구체화해 프로그램을 만듦, 패턴 구성 방법

### CASE(Computer Aided Software Engineering)

소프트웨어 개발 과정에서 사용되는 요구분석/설계/구현/검사 등의 과정 전체나 일부를 컴퓨터 전용 소프트웨어 도구로 자동화하는 것.

### LOC 기법

source Line of Code. 원시 코드 라인 수 기법이라고도 한다. 

- 노력(인월) = (개발 기간) * (투입 인원) = LOC / (인당 월 평균 생산 코드 라인 수)
- 개발비용 = 노력 * (단위 비용)
- 개발 기간 = 노력 / (투입 인원)
- 생산성 = LOC / 노력(인월)

### 수학적 산정 기법

상향식 비용 산정 기법이다. 프로젝트의 모듈 별 비용을 합쳐 전체 비용으로 추정한다. 개발 비용 산정의 자동화를 목표로 한다.

### 수학적 산정 기법 - COCOMO 모형

Constructive Cost Model. LOC에 의한 비용 산정 기법이다. 보헴이 제안했다. 

개발할 소프트웨어의 규모를 예측하고 이를 소프트웨어의 규모에 따라 비용을 산정한다. 결과는 인당 월별로 나타난다. 

- `조직형`: LOC < 5만
    
    기관 내부에서 개발된 중/소규모의 소프트웨어들이 해당한다. 보통 사무처리용, 업무용, 과학용 응용 소프트웨어들이다.
    
- `반분리형`: LOC < 30만
    
    트랜잭션 처리 시스템, 운영체제, DBMS 등의 소프트웨어나 컴파일러, 인터프리터 등의 유틸리티 개발에 해당한다.
    
- `내장형`: LOC 30만~
    
    신호기 제어, 미사일 유도 시스템, 실시간 처리 시스템 등이 해당한다. 트랜잭션 처리 시스템이나 운영체제 역시 여기에 해당하기도 한다.
    

### 수학적 산정 기법 - Putnam 모형

소프트웨어 생명 주기의 전 과정 동안에 사용될 노력의 분포를 추정하므로, 생명 주기 예측 모형이라고도 한다. Putnam 사에서 제안했다. 

시간에 따른 노력의 분포이므로 Rayleigh-Norden 곡선의 노력 분포도를 기초로 한다.

### CPM

Critical Path Method, 임계 경로 기법. 프로젝트 완성에 필요한 작업을 나열하고 소요 시간을 예측한다. 알고리즘 중 위상정렬과 유사한 형태를 보인다.

최장 경로를 임계 경로라고 하고 이를 굵은 줄로 표시한다.

### CMMI(Capability Maturity Model Integration)

소프트웨어 개발 조직의 업무 능력 및 성숙도를 평가하는 모델이다.

1. `초기`: 작업자 능력에 따라 성공 여부 결정
2. `관리`: 특정한 프로젝트 내의 프로세스 정의 및 수행
3. `정의`: 조직의 표준 프로세스를 활용해 업무를 수행
4. `정량적 관리`: 프로젝트를 정량적으로 관리 및 통제
5. `최적화`: 지속적으로 프로세스 개선

### SPICE(Software Process Improvement and Capability Determination)

소프트웨어 품질 및 생산성 향상을 위해 소프트웨어 프로세스를 평가 및 개선하는 국제 표준. a.k.a `ISO/IEC 15504`

1. `불완전`: 프로세스가 구현되지 않았거나 목적을 달성하지 못함
2. `수행`: 프로세스가 수행되고 목적을 달성함
3. `관리`: 정의된 자원의 한도 내에서 작업 산출물 인도
4. `확립`: 소프트웨어 공학 원칙에 기반해 정의된 프로세스 수행
5. `예측`: 프로세스가 목적 달성을 위해 통제되고 양적인 측정을 통해 일관되게 수행됨
6. `최적화`: 지속적인 개선을 통해 업무 목적을 만족시키는 단계

### 소프트웨어 개발 프레임워크

소프트웨어 개발에 공통적으로 사용되는 구성 요소와 아키텍쳐를 일반화해서 제공하는 소프트웨어 시스템. 우리가 잘 아는 Spring이 해당한다.

- `모듈화`
    
    캡슐화를 통해 모듈화를 강화(응집 Up 결합 Down)하고, 이를 통해 설계 및 구현 변경에 따른 영향을 최소화한다. 유지 보수가 용이하다.
    
- `재사용성`
    
    모듈을 재사용할 수 있다 → 예산도 줄고 생산성도 향상된다. 품질도 보증 가능하다.
    
- `확장성`
    
    다형성을 통한 인터페이스 확장이 가능하다. 
    
- `제어의 역흐름(IoC)`
    
    개발자가 관리해야 하는 객체의 제어를 프레임워크가 대신한다 → 생산성 향상