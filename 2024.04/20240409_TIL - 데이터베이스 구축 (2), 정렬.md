# 20240409_TIL - 데이터베이스 구축 (2),  정렬

## 데이터베이스 구축

### View

사용자에게 접근이 허용된 데이터만 보여주기 위해 만들어진 가상 테이블.

하나 이상의 기본 테이블에서 유도되었으며 연결된 기본 테이블이 삭제되면 관견된 뷰가 모두 삭제된다.

정의 시에는 `CREATE`, 삭제 시에는 `DROP`문을 사용한다.

### 파티션

데이터베이스의 특정 데이터 부분을 여러 섹션으로 분할한다. 

- 대용량 데이터의 조회속도 향상, 관리가 용이함, 성능 및 가용성 향상
- 테이블 간의 조인 비용 증가, 인덱스도 동일한 파티셔닝 방식을 택해야 함

분할 방식은 다음과 같은 방법들이 있다.

| 분할 방식 | 범위 분할 | 목록 분할 | 해시 분할 | 라운드 로빈 분할 | 합성 분할, 조합 분할 |
| --- | --- | --- | --- | --- | --- |
| 기준 | 파티션 키가 되는 열의 연속된 범위 | 그룹화 가능한 데이터의 리스트 이름 | 파티션 키의 값에 해시 함수를 적용 | 순차적으로 돌려가며 저장 | 위의 기술들을 복합적으로 사용 |
| 특징 | 해당 기준으로 많이 검색이 실행되면 유용 | 해당 속성에 대한 조건이 많이 들어오면 유용함 | 데이터가 모든 파티션에 고르게 분산되도록 관리
병렬 처리시 성능 효과가 극대화 | 균일한 분배를 보장한다. | 보통 해시 함수를 같이 사용하는 듯 |
| 예시 | 월별, 분기별 | [한국, 중국, 일본] ⇒ 아시아 |  |  |  |

### 분산 데이터베이스의 목표

- `위치 투명성`
    
    DB별 분산된 위치와 상관 없이 DB의 논리적인 명칭만으로 사용자는 정상적인 이용이 가능하다.
    
- `중복 투명성`
    
    동일한 데이터가 여러 DB에 중복되어 저장되어도 사용자는 하나의 데이터에만 존재한다고 생각한다. 시스템은 자동으로 중복된 데이터에 대해 모두 작업을 처리한다.
    
- `병렬 투명성`
    
    DB에서 여러 개의 트랜잭션이 동시에 작동해도 서로에게 영향을 주지 않는다.
    
- `장애 투명성`
    
    컴퓨터나 DBMS, 트랜잭션 혹은 네트워크의 장애가 발생해도 트랜잭션을 정확하게 처리한다.
    

### RTO / RPO

- `RTO(Recovery Time Objective)`: 복구까지 걸릴 시간
- `RPO(Recovery Point Objective)`: 복구될 시점

<br>

## 정렬

### 삽입 정렬

정렬된 인덱스에 새로운 레코드를 하나씩 추가하는 방법

```java
초기 상태: 8 | 5 6 2 4 (하나의 index는 정렬된 것이나 마찬가지라고 간주) 
1회전: 5 8 | 6 2 4
2회전: 5 6 8 | 2 4
3회전: 2 5 6 8 | 4
4회전: 2 4 5 6 8 |
```

### 선택 정렬

n개의 데이터 중 최대 / 최소값을 찾아 0번째 index로, n-1개의 데이터 중에서 1번째 index로… 반복하기

```java
초기 상태: 8 5 6 2 4
1회전(5개): 5 8 6 2 4 -> 5 8 6 2 4 -> 2 8 6 5 4 -> 2 8 6 5 4
2회전(4개): 2 | 6 8 5 4 -> 2 | 5 8 6 4 -> 2 | 4 8 6 5
3회전(3개): 2 4 | 5 6 8 -> 2 4 | 5 6 8
4회전(2개): 2 4 5 | 6 8 (종료)
```

### 버블 정렬

인접한 두 개의 레코드 값을 비교하는 과정 반복

```java
초기 상태: 8 5 6 2 4
1회전: 5 8 6 2 4 -> 5 6 8 2 4 -> 5 6 2 8 4 -> 5 6 2 4 8
2회전: 5 2 6 4 8 -> 5 2 4 6 8 -> 5 2 4 6 8
3회전: 2 5 4 6 8 -> 2 4 5 6 8
4회전: 2 4 5 6 8 (변화 x)

```

### 퀵 정렬

pivot을 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽으로 보내는 과정을 반복하면서 정렬한다. 

일반적으로 O(nlogn)으로 훌륭한 시간 복잡도를 보인다. 최악의 경우 O(n^2)가 된다.

### 힙 정렬

완전 이진 트리를 힙 트리로 만들어 최대 / 최소 순으로 저장한다. 

O(nlogn)으로 훌륭한 시간 복잡도를 보인다. 

### 병합 정렬

이미 정렬되어 있는 두 리스트를 하나로 합병하는 방식이다. 분할 정복 알고리즘을 활용한다. 

O(nlogn)으로 훌륭한 시간 복잡도를 보인다.