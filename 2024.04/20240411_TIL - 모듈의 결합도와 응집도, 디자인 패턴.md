# 20240411_TIL - 모듈의 결합도와 응집도, 디자인 패턴

## 모듈

모듈화를 통해 분리된 시스템의 각 기능. 하나 OR 여러 개의 논리적인 기능 수행을 위한 명령어의 집합이다. 

모듈 사이의 결합도가 낮고 모듈 내 응집도가 높을 수록 (성능이) 좋은 모듈이다.

### 결합도(Coupling)

모듈 간에 의존하는 정도.

1. `내용(Content) 결합도`: 가장 강함(안 좋음)
    
    한 모듈이 다른 모듈의 변수나 메소드를 직접 참조하거나 수정한다.
    
2. `공통(Common) 결합도` 
    
    파라미터가 아닌 모듈 밖에 선언된 전역 변수를 참조한다. 여러 모듈이 이 값을 갱신하면서 상호작용하는 방식이다.
    
3. `외부(External) 결합도`
    
    어떤 모듈에서 선언한 변수를 외부의 다른 모듈이 사용한다.
    
4. `제어(Control) 결합도` 
    
    단순히 처리해야 할 값 이외에도 처리 방식을 가리키는 제어 요소가 함께 전달된다.
    
5. `스탬프(Stamp) 결합도`
    
    모듈 간의 인터페이스로 배열이나 오브젝트, 스트럭쳐 등이 전달된다.
    
6. `자료(Data) 결합도`: 가장 약함(좋음)
    
    모듈 간의 인터페이스로 순수 데이터(==값)만 전달 된다.
    

### 응집도(Cohesion)

모듈의 내부 요소들이 서로 관련되어 있는 정도.

1. `기능적(Functional) 응집도`: 가장 강함(좋음)
    
    모듈 내부의 모든 기능이 단 하나의 목적을 위해 실행된다.
    
2. `순차적(Sequential) 응집도` 
    
    한 활동으로 나온 반환값이 모듈 내 다른 활동의 입력값으로 사용된다.
    
3. `통신적(Communication) 응집도`
    
    동일한 입출력으로 다른 기능을 수행하는 활동들이 모듈 안에 모여 있다.
    
4. `절차적(Procedual) 응집도` 
    
    모듈의 다수의 관련 기능을 가질 때, 구성 요소들이 해당 기능을 순차적으로 수행한다.
    
5. `시간적(Temporal) 응집도`
    
    연관된 기능이라기보다는 그냥 특정 시간대에 처리 요소의 모임
    
6. `논리적(Logical) 응집도`
    
    유사한 성격을 갖거나 특정 형태로 분리되는 처리 요소의 모임
    
7. `우연적(Coincidental) 응집도`: 가장 약함(안 좋음)
    
    그냥 아무 사이도 아님
    

### 팬인 / 팬아웃

특정 모듈을 호출하거나 참조하는 상위 모듈/하위 모듈의 수를 말한다. 모듈과 전체 시스템의 복잡도와 상호작용 정도를 분석하는 지표가 된다.

- 모듈의 팬인이 높으면 해당 모듈은 중요성과 재사용성이 높은 모듈이다.
- 모듈의 팬아웃이 높으면 여러 모듈과 상호 작용이 많은 모듈이다.

시스템의 복잡도를 최적화하기 위해서는 되도록 상위 모듈에서 하위 모듈을 호출하는 방향으로 가는 것이 좋다. 

### IPC(Inter-Process Communication)

모듈 간 통신방식을 구현하기 위한 대표적인 프로그래밍 인터페이스 집합이다. 이름에서 알 수 있듯이 프로세스 간의 통신도 구현된다.

- `공유 메모리`
- `소켓`
- `세마포어`
- `파이프, 네임드 파이프`
- `메시지 큐잉`

### 재사용

이미 개발된 기능을 새로운 시스템이나 기능 개발에 사용하기 적합하도록 최적화하는 작업을 말한다. 새로운 애플리케이션 개발 시 개발에 필요한 비용이나 시간을 절약할 수 있다. 

누구나 이해할 수 있고 사용이 가능하도록 사용법을 공개해야 한다.

- `함수와 객체 재활용`: 클래스나 메소드 단위로 소스 코드를 재사용하는 방식
- `컴포넌트 재활용`: 컴퓨넌트 자체에 대한 수정 없이 인터페이스를 통해 통신하는 방식
- `애플리케이션 재활용`: 만들려는 기능을 똑같이 제공하는 애플리케이션을 공유하는 방식

<br>

## 디자인 패턴

디자인 패턴은 모듈 간 인터페이스 설계 시 참조할 수 있는 템플릿이다. 아키텍쳐 패턴(소프트웨어 구조 설계 시 참조)과 유사하다.

### 생성 패턴

클래스나 객체 생성, 참조 과정을 정의한다. 객체 생성시 프로그램 구조에 영향을 주지 않는 유연성을 제공한다.

- `추상 팩토리(Abstract Factory)`
    
    구체적인 클래스가 아니라 추상적인 인터페이스를 통해 관련된 클래스들의 조합을 만든다. 
    
    관련된 서브 클래스들을 수정하기에 간편하다.
    
- `빌더(Bulider)`
    
    여러 필드값을 갖는 객체의 인스턴스 생성 시 표현 방법을 분리해 동일한 객체를 생성하면서도 다른 결과를 만들 수 있다.
    
    ```java
    Developer d = new Developer.Builder()
                                .name("박동건")
                                .age(27)
                                .build();
    ```
    
- `팩토리 메소드(Factory Method)`
    
    객체 생성을 서브 클래스에서 처리하도록 분리한다. 객체 자체는 정보만 담는다.
    
    ```java
    abstract class UserFactory {
    	public abstract User createUser();
    }
    
    class DeveloperFactory extends UserFactory {
    	@Override
    	public User createUser() {
    		return new Developer();
    	}
    }
    
    UserFactory df = new DeveloperFactory();
    
    User u = df.createDeveloper();
    u.setName("박동건");
    u.setAge(27);
    u.setYear(1);
    ```
    
- `프로토타입(Prototype)`
    
    원본 객체를 복사한다. java에선 `clone()` 메소드를 사용한다.
    
- `싱글톤(Singleton)`
    
    어떤 클래스의 인스턴스는 하나임을 보장하고 어디서든 참조 가능하게 한다. 
    
    ```java
    public class UserServiceImpl implements UserService {
    	// 원본 인스턴스 생성
    	private static UserService us = new UserServiceImpl();
    	
    	// 생성자 차단, 외부에서 생성 불가
    	private UserServiceImpl() {}
    
    	// 외부에서 필요시 getInstance 호출을 통해 원본 인스턴스 사용하도록 유도 	
    	public static UserServiceImpl getInstance() {
    		return us;
    	}
    }
    ```
    

### 구조 패턴

클래스와 객체를 조합해 더 큰 구조를 만들 때 사용한다. 상속을 통해 클래스나 인터페이스를 합성한다.

- `어댑터(Adapter)`
    
    클래스의 인터페이스를 다른 인터페이스로 변환해 다른 클래스가 사용할 수 있게 한다.
    
    기존 클래스를 이용하고 싶지만 인터페이스가 일치하지 않아서 못하는 경우 사용한다.
    
- `브리지(Bridge)`
    
    구현부에서 추상화된 부분을 분리한다. 즉 기능과 구현이 서로 다른 클래스로 구현된다.
    
    ```java
    // 기능 추상화
    interface User {
    	public void introduce();
    }
    
    // 구현
    class Developer implements User {
    	@Override
    	public void introduce() {
    		System.out.println("안녕하세요! 저는 개발자입니다.");
    	}
    }
    class Student implements User {
    	@Override
    	public void introduce() {
    		System.out.println("안녕하세요! 저는 학생입니다.");
    	}
    }
    ```
    
- `컴포지트(Composite)`
    
    하나 이상의 유사한 객체들을 트리 구조로 구성해 새로운 객체로 만든다.
    
    객체 안에 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고 싶을 때 사용한다.
    
- `데코레이터(Decorator)`
    
    상황에 따라 객체에 다른 객체를 덧붙인다. 
    
    객체 간의 결합으로 능동적인 기능 확장이 가능하다.
    
- `파싸드(Facade)`
    
    서브 클래스 위에 인터페이스를 구성한다.
    
    복잡한 서브 클래스 안에 있는 객체들을 편하게 사용하게 한다.
    
    이를 위해서는 서브 클래스들 사이의 통합 인터페이스인 `Wapper` 가 정의되어야 한다.
    
- `플라이웨이트(Flyweight)`
    
    인스턴스가 필요할 때 매번 생성하기보다 되도록 기존 인스턴스를 공유해서 메모리를 절약한다.
    
- `프록시(Proxy)`
    
    접근이 어려운 객체로 접근을 제어하기 위해 대리자를 세운다. 
    
    내부로는 객체 간의 복잡한 관계 정리해주고 외부에서는 객체의 세부 내용이 안 보이게 한다.
    

### 행위 패턴

객체나 클래스들이 상호작용하는 방법과 책임을 할당한다. 객체 간의 효율적인 커뮤니케이션을 돕는다.

- `책임 연쇄(Chain of Responsibility)`
    
    한 객체가 처리할 수 없는 요청을 다음 객체로 전달한다.
    
- `커맨드(Command)`
    
    요청에 사용되는 각종 명령어들을 추상 클래스와 구현 클래스로 분리한다. 이후 들어오는 요청을 구현한 객체의 형태로 단순화한다.
    
    ex) 로그, 큐 관리, 실행 취소/재실행 기능 등
    
- `인터프리터(Interpreter)`
    
    주어진 언어에 대해 그 언어의 문법에 대한 표현을 정의하고, 해당 언어를 해석하는 해석자를 위한 패턴을 만든다.
    
    ex) SQL, 통신 프로토콜, 복잡한 문법을 가진 프로그래밍 언어의 인터프리터 등
    
- `반복자(Iterator)`
    
    컬렉션 객체의 내부 구조를 노출시키지 않고도 원소에 접근하는 방법을 제공한다. index 없이도 원소들에 순차적인 접근을 가능하게 한다. 
    
- `중재자(Mediator)`
    
    객체 간의 복잡한 상호작용을 캡슐화해 중재자 객체로 정의한다. 객체 간의 직접 참조를 피해 결합도를 낮춘다.
    
- `메멘토(Memento)`
    
    객체의 상태 정보를 저장하고 저장된 상태로 복원할 수 있는 기능을 제공한다.
    
- `옵저버(Observer)`
    
    객체가 본인의 상태 변화를 관찰하는 관찰자들의 목록을 갖는다. 상태 변화가 있을 때마다 객체가 목록에 있는 관찰자들에게 통지한다.
    
- `상태(State)`
    
    객체 상태를 또 다른 객체로 표현한다. 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용한다. 상태 전이 방식을 더 명확하게 표현할 수 있다.
    
- `전략(Strategy)`
    
    동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있도록 정의한다. 알고리즘을 쉽게 바꿔 사용하게 해준다.
    
- `템플릿 메소드(Template Method)`
    
    상위클래스는 알고리즘의 골격만을 작성하고 구체적인 처리는 서브 클래스로 위임한다.
    
- `방문자(visitor)`
    
    객체 구조를 이루는 원소에 대한 연산을 정의하는 데 사용된다. 새로운 연산을 추가하더라도 객체 구조를 변경하지 않게 해준다.
    
    확장에는 열려 있지만 수정에는 닫혀 있는, 객체지향 원칙 중 `개방-폐쇄 원칙`을 적용한 방식이다.
    
<br>

## 기타

### N-S 차트

논리의 기술에 중점을 두고 `연속`, `선택 및 다중 선택(분기)`, `반복`의 3가지 제어 논리 구조를 도형을 이용해 표현한다. 

조건이 복잡한 곳의 처리를 시각적으로 명확히 처리 가능하다.

GOTO나 화살표를 이용하지 않는다. 

### 테스트 케이스

작성된 코드가 사용자의 요구사항을 정확하게 준수하는지 확인하기 위한 테스트 항목의 명세서.

- `식별자`: 테스트 항목 식별자, 일련번호
- `테스트 항목`: 테스트 하려는 모듈이나 기능
- `입력 명세`: 테스트 데이터, 조건(흔히 말하는 ‘테케’)
- `출력 명세`: 테스트 데이터에 따라 예상되는 출력 결과
- `환경 설정`: 필요한 하드웨어 / 소프트웨어 환경
- `특수 절차 요구`: 테스트 실행 시 특별히 요구되는 절차
- `의존성 기술`: 테스트 케이스 간의 의존성

### 코드

데이터를 분류하고 조합 / 집계 / 추출을 쉽게 하기 위해 사용하는 기호.

- `식별`: 데이터의 성격에 따라 코드를 다르게 부여해서 구분이 가능
- `분류`: 특정 기준이나 동일한 유형이면 유사한 코드를 부여해서 그룹화 가능
- `배열`: 코드 상에 의미를 부여해 나열 가능
- `표준화`: 다양한 데이터를 코드라는 기준에 맞춰 표준화
- `간소화`: 복잡한 데이터를 코드라는 기준에 맞춰 간소화

종류엔 여러가지가 있다.

- `순차 코드`
    
    최초의 자료부터 sequential number를 붙인다. 일련번호 코드라고도 한다.
    
    ex) 1, 2, 3, 4 …
    
- `블록 코드`
    
    코드화할 항목을 공통성이 있는 것들끼리 블록으로 구분하고 그 안에서 일련번호를 부여한다.
    
    ex) 1001 ~ 1100: 총무부, 1101~1200: 영업부 …
    
- `10진 코드`
    
    항목들을 필요한 만큼 10진 분할(0~9)하기를 반복한다. 도서분류식 코드라고도 한다.
    
    ex) 1000: 공학, 1100: 산업공학, 1110: 응용통계학 ….
    
- `그룹 분류 코드`
    
    항목들을 일정 기준에 따라 대/중/소분류 등으로 구분하고 그 안에서 일련번호를 붙인다.
    
    ex) 1-01-001 : 본사 - 임원부 - 비서계
    
- `연상 코드`
    
    코드화할 항목의 관계 있는 숫자나 문자, 기호를 이용해 코드를 붙인다.
    
    ex) TV-40 :  40인치 TV
    
- `표의 숫자 코드`
    
    항목의 물리적 수치를 그대로 코드로 붙인다. 유효숫자 코드라고도 한다.
    
    ex) 120-720-1500 : 부피가 120 x 720 x 1500인 무언가
    
- `합성 코드`
    
    이중 뭐 하나 쓰기 애매하면 2개 이상의 코드를 조합해서 만든다.
    
    ex) KE-711: 대한항공 711기
