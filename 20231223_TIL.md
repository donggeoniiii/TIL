# 20231223_TIL - JVM 클래스 로더

---

## JVM 클래스 로더

### Recap

- Java는 어떤 플랫폼에서도 잘 돌아가는 소프트웨어를 만들기 위해 고안된 언어다
    
    → 그렇기 때문에 JVM을 통해 어떤 OS, 어떤 CPU에서도 동일하게 실행되는 소스코드를 작성하게 했다(JVM은 플랫폼에 따라 다를 수 있음, OS와 CPU 위에서 실행되니까)
    
- JVM에는 JVM의 메모리와 클래스로더, 실행엔진이 있다
- 클래스 로더는 명령어 단위로 필요한 클래스를 Java 라이브러리에서 불러오는 역할을 한다.
- 클래스 로더는 계층 구조로 상위 클래스 로더로 올라가면서 로드 여부를 확인한다.
- 하위 클래스는 상위 클래스의 탐색 결과를 알 수 있지만, 반대는 불가능하다. 이를 통해 중복호출을 피하고 효율적인 탐색을 추구한다(상위 클래스에서 호출했으면 따로 호출 x)
- 실행 엔진은 인터프리터와 JIT 컴파일러로 나뉜다.
- 기본적으로 바이트코드 하나씩 네이티브 코드(기계어)로 변환해 인터프리터 방식으로 실행시킨다.
- 자주 불러오는 클래스의 경우 JIT 컴파일러가 읽을 때마다 캐시에 보관해 중복 호출되는 클래스를 인터프리팅 방식으로 읽지 않도록 방지한다.
- JIT의 성능은 Java 인터프리터의 10~20배 속도라고 한다.

### 클래스 로더의 종류

위에서 아래로 상위 → 하위 클래스이다. 

- Bootstrap Class Loader(부트스트랩 클래스 로더)
    
    최상위 클래스 로더, Java 코드가 아닌 네이티브 코드(기계어)이다. JVM이 실행될 때 메모리에 올라간다. Java API들을 로드한다(일반적으로 `jre/lib`에 있는 JAR 파일).
    
- Extension Class Loader(확장 클래스 로더)
    
    기본 Java API를 제외한 확장 클래스들을 로드한다. 여기까진 JVM 자체의 구성요소들을 로드한다(주로 `jre/lib/ext`에 위치한 Extension 디렉토리나 `java.ext.dirs` 환경 변수로 지정된 폴더에 있는 클래스 파일에서 클래스들을 로딩).
    
- System Class Loader
    
    사용자가 지정한 $CLASSPATH 환경변수 안의 클래스들을 로드한다. 사용자가 생성한 모든 클래스 로더의 부모가 된다.
    
- User-Defined Class Loader(aka 어플리케이션 클래스 로더)
    
    어플리케이션 사용자가 직접 코드상에서 생성하여 사용하는 클래스들을 불러오는 클래스 로더다.
    

클래스 로더들 역시 클래스이기 때문에 로드 되어야 하는데, 이는 부트스트랩 클래스 로더가 한다.

### 클래스 로더 작동 원리

<aside>
💡 JVM이 어떤 명령어를 위해 클래스를 요청하면, 클래스 로더가 탐색 후 메모리에 올린다.

</aside>

먼저 JVM의 method 영역에 해당 클래스가 있으면 그 클래스를 쓴다. 없으면 어플리케이션 클래스 로더부터 클래스 로드를 요청한다.

`위임 모델` 방식으로 작동하며, 클래스 로딩을 요청받으면 로딩한 적이 있는지 `클래스 로더 캐시`를 먼저 살펴보고 그 후 상위 클래스에서 클래스를 로딩한 적 있는지 거슬러가며 탐색한다.

만약 한번 올라가기 시작하면 최상위 부트스트랩 클래스 로더까지 무조건 거슬러 올라간다(근데 이건 WAS 벤더에 따라 다르기도 하다고 함). 그리고 가장 최상위에 있는 클래스를 로드한다.

최상위 클래스 로더에서도 찾지 못한 클래스가 있다면 위에서부터 다시 내려가며 찾는다. 찾는 영역은 위에 쓴 내용이므로 생략

마지막으로 어플리케이션 클래스 로더까지 와서 없으면 `ClassNotFoundException`을 던진다.

### 클래스 로더 네임스페이스

각 클래스 로더들이 가지고 있는 공간으로써 로드된 클래스를 보관하는 공간. 이미 로딩된 클래스는 로드해선 안되고 상위 클래스로더가 로딩한 것을 다시 한번 로딩하지 않기 위해 사용한다.