# 20240102_TIL - Stream, Record, Composition

## Stream

Java에서 제공하는 API. 람다를 이용한 함수형 프로그래밍을 할 수 있게 도와주는 API다. Collection과 비슷하지만 조금 다르다. Java 8부터 지원한다. 

### Collection과 Stream의 차이

<aside>
💡 Collection은 핸드폰에 음악 파일을 미리 저장하여 재생하는 플레이어라면, Stream은 말 그대로 실시간 스트리밍 사이트처럼 필요할 때 검색해서 듣는 거라고 생각하면 된다.

</aside>

Collection은 외부 반복을 통해 사용자가 직접 반복작업에 관여할 수 있다.

Stream은 내부 반복을 사용해서 추출할 요소만 선언하면 알아서 모든 요소에 대해 반복 처리를 진행한다. 그러나 Stream 내에 요소를 추가하거나 삭제할 수는 없다. 그 대신 단순 반복 성능은 더 뛰어나다.

한편 Collection에서 `synchronized` 키워드를 통해 관리해주면 병렬성을 이용할 수 있다.

### Stream의 연산 과정

`중간`과정과 `최종`과정으로 나뉜다.

`중간`과정은 파이프라이닝이 가능하다. 반환하는 결과값은 모두 Stream의 형태로, 최종과정이 있어야 비로소 우리가 원하는 자료구조의 반환이 가능하다.

- `filter()`: 해당하는 요소를 제외한 값을 찾는다.
- `distinct()`: 중복을 필터링한다.
- `map()`: 해당하는 요소를 찾는다.
- `limit(n)`: 전체 해당 요소에서 n개 이하만큼 요소를 찾는다.
- `skip()`: 처음 n개를 제외한 결과를 얻는다.

`최종`연산은 스트림을 닫는다. 

- `(boolean) allMatch()`: 모든 스트림 요소가 일치하는지 검사하고 True/False 반환
- `(boolean) anyMatch()`: 하나라도 일치하면 True 반환
- `(boolean) noneMatch()`: 일치하는 요소가 없으면 True 반환
- `(Optional) findAny()`: 스트림의 임의의 요소 반환
- `(Optional) findFirst()`: 스트림의 첫 번째 요소 반환
- `reduce()`: 모든 스트림 요소를 처리해서 하나의 값으로 도출한다. 반환 방식은 조건식과 요소의 자료형에 따라 여러가지일 수 있다.
- `collect()`: stream을 `reduce`해 컬렉션으로 만든다. list, map, 정수 형식 등이 가능하다.
- `forEach()`: 람다를 이용한 함수형 프로그래밍을 가능하게 해준다. 각각의 요소에 접근이 가능하다.
- `(Long) count`: 스트림 요소의 개수르 반환한다.

## Record

Java 14부터 도입, 16부터 정식으로 포함되었다. 클래스 타입으로 단순히 데이터를 `보유`하기 위한 형태다. 아직 잘 모르지만 코틀린의 데이터 클래스와 비슷하다고 한다.

자동으로 필드를 `private final`로 선언해주고, 모든 필드를 초기화하는 생성자와 getter, 그리고 equals 등의 `Object`에서 제공하는 메소드들을 자동으로 생성해준다. 주의할 점이 있다면 getter의 경우 이름이 `get`이 붙지 않고 그대로 `필드명()`이 된다.

생성자를 명시적으로 쓸 수도 있다. 다만 기본적인 것들을 알아서 제공해준다는 의미다.

## Composition(a.k.a forwarding)

기존 클래스가 새로운 클래스의 구성요소가 되는 것을 말한다. 상속의 단점을 커버할 수 있다.

상속의 경우 하위 클래스가 상위 클래스를 한 개 상속하게 되면, 다중 상속이 불가능하다. 그리고 객체 지향 프로그래밍의 중요한 부분인 캡슐화를 위반한다.

> 상속은 기본적으로 `IS-A` 관계가 반드시 성립해야 한다.
> 

Composition 방식은 기존 클래스를 확장하는 상속과 다르게, 완전 별개의 새로운 클래스를 생성해 기존 클래스의 인스턴스를 참조하는 방식이다. 새로운 클래스에서 인스턴스 하나를 참조하는 방식이므로 어떠한 작업이 일어나더라도 기존의 클래스는 영향을 받지 않는다. 

기존의 상속 방식보다 Composition 방식을 사용하는 것이 좀 더 객체지향적인 설계이고, 구조의 유연함을 보장할 수 있다.