# 20240124_TIL - CPU 스케줄링

프로세스는 생성 후에도 운영체제로부터 CPU 자원을 할당 받아야 한다. 그렇지만 운영체제는 마구잡이로 프로세스에게 자원을 할당할 수 없다. 

이를 위해 프로세스별로 우선순위를 매겨 할당하는 방식을 가진다. 이를 CPU 스케줄링이라고 한다.

## CPU 스케줄링

운영체제는 우선순위가 먼저인 프로세스부터 필요한 CPU 자원을 할당한다. 우선순위가 높은 프로세스는 주로 입출력 작업이 많은 프로세스를 말한다. 

근데 왜 입출력 작업이 많은 프로세스를 먼저 실행하는 것이 효율적일까? 그냥 요청하는 순서대로 CPU를 사용하라고 하면 안될까?

### 프로세스 우선순위

프로세스가 실행되는 과정을 생각해보자. 대부분의 프로세스는 내부에서 CPU를 사용하고 결과를 입출력장치를 통해 내보내는 과정을 반복한다. 여기서 내부에서 CPU를 사용하는 과정을 `CPU 버스트`, 입출력장치를 사용하는 과정을 `입출력(I/O) 버스트`라고 한다.

여기서 두 개의 프로세스에 대해 떠올려보자. 

```jsx
A: 유튜브 영상을 재생, 입출력 버스트가 많은 프로세스 -> `입출력 집중 프로세스` 
	=> `대기` 상태로 있는 시간이 더 많다. 

B: 유튜브에 영상을 올리기 위해 렌더링 작업, CPU 버스트가 많은 프로세스 -> `CPU 집중 프로세스` 
	=> `실행` 상태로 있는 시간이 길다.  

만약 두 프로세스가 동일하게 CPU를 할당받는다면, CPU 자원 사용 차이로 인해 비효율이 발생
```

따라서 이 경우 입출력 집중 프로세스 A에 프로세스를 먼저 할당, 빨리 `실행`시켜서 입출력장치를 작동시킨 후 `대기` 상태로 만들고, 그 후에 긴 시간을 CPU 집중 프로세스인 B에 집중적으로 `실행` 상태로 할당시키는 것이 합리적이다. 

운영체제는 각 프로세스의 PCB에 이 우선순위를 명시하고, PCB에 적힌 우선순위를 기준으로 먼저 처리할 프로세스를 결정한다. 우선순위가 높은 프로세스가 더 빨리, 더 자주 실행된다.

### 스케줄링 큐

PCB에 우선순위가 적혀 있더라도, 이를 운영체제가 모든 프로세스의 PCB를 뒤져가며 순서를 매기게 만드는 것은 효율적이지 못하다. 컴퓨터가 실행되는 동안에 줄 서있는 프로세스는 생각보다 많고, 그 사이에서 또 새로운 프로세스가 생성될 수도 있기 때문이다.

그래서 운영체제는 프로세스들에게 줄을 서서 기다리라고 한다. CPU를 쓰고 싶은 프로세스, 하드 디스크를 쓰고 싶은 프로세스, 여러 입출력장치를 쓰고 싶은 프로세스 등 사용 기준을 들어 줄을 서게 만드는데, 이 줄들을 `스케줄링 큐(queue)`라고 한다. 운영체제가 관리하는 대부분의 자원은 이런 방식으로 관리된다.

여기서 CPU를 쓰고 싶은 프로세스들이 서는 줄을 `준비 큐(ready queue)`라고 하고, 입출력장치를 쓰고싶은 프로세스들이 서는 줄을 `대기 큐(waiting queue)`라고 한다. 프로세스의 상태와 이름이 비슷한 이유는 우연이 아니다.

`준비` 상태에 있는 프로세스들은 CPU 자원을 할당받아 실행되기를 기다리는 것이다. 그렇지만 코어는 한 번에 하나의 프로세스만 실행할 수 있다. 따라서 여러 준비단계에 있는 프로세스들은 줄을 서서 자기 차례를 기다려야 한다. 운영체제는 큐의 LIFO 특성을 이용해 가장 우선순위가 높은 프로세스부터 하나씩 실행시킨다.

`대기` 상태에 있는 프로세스들은 입출력 작업이 완료되기를 기다리는 것이다. 마찬가지로 한 번에 한 프로세스만 작업할 수 있으므로, 대기 큐에서 앞선 입출력 작업이 끝난 후 운영체제에 의해 할당받기를 기다린다. 이후 입출력 작업이 끝나면, 인터럽트가 발생해 해당 프로세스는 `준비` 상태가 되고, `준비 큐`에 추가되어 CPU를 할당받기를 기다리거나 종료될 것이다.

### 선점형, 비선점형 스케줄링

운영체제의 입장에서 생각해보자. 한 프로세스가 CPU를 잘 사용하고 있는데, 갑자기 생성된 프로세스가 정말 급한 일이라고 사용을 요구하면 어떻게 될까? 

방법은 단순하게 두 가지가 있다. 이전 프로세스의 자원을 빼앗거나, 기다리라고 하거나. 전자를 `선점형 스케줄링`, 후자를 `비선점형 스케줄링`이라고 한다. 

`선점형 스케줄링`은 프로세스가 이전에 CPU를 할당받아 사용하더라도 빼앗길 수 있는 방식이다. 이 경우 한 프로세스의 자원 독점을 막고 고른 자원의 배분이 가능하지만, 문맥 교환이 자주 발생하므로 과정에서 오버헤드가 발생할 수 있다.

 `비선점형 스케줄링`은 하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되거나 실행상태에서 벗어나기 전까지 다른 프로세스가 끼어들 수 없는 방식을 말한다. 문맥 교환이 일어나는 수 자체는 적지만, 당장 자원을 사용해야 하는 경우에도 무작정 기다릴 수 밖에 없다는 단점이 있다.

현재 대부분의 운영체제는 선점형 스케줄링 방식을 사용하고 있다. 

## CPU 스케줄링 알고리즘

늘 그렇듯이, CPU 제품에 따라 매우 다양하다. 각 알고리즘의 작동 방식과 장단점만 알아보자.

### 선입 선처리 스케줄링(First-Come-First-Served Scheduling)

준비 큐에 삽입된 순서대로 먼저 요청한 프로세스를 먼저 처리하는 비선점형 스케줄링을 말한다. 제일 단순한 방식이다. 전술한 것처럼 프로세스 종류에 따라 프로세스들이 기다리는 시간이 길어질 수도 있다. 

상대적으로 실행 시간이 짧은 프로세스가 선입력된 프로세스들에 의해 대기하는 것을 `호위 효과(convoy effect)`라고 한다.

### 최단 작업 우선 스케줄링(Shortest-Job-First Scheduling)

호위효과를 없애려면 어떻게 하면 될까? 제일 빨리 끝나는 작업을 제일 먼저 하면 된다. 그렇게 하는 스케줄링 방식이다. 

비선점형 스케줄링으로 분류되지만 선점형 스케줄링으로 구현되기도 한다. 이는 후에 설명할 `최소 잔여시간 우선 스케줄링`으로 이어진다.

### 라운드 로빈 스케줄링(Round Robin Scheduling)

선입 선처리 스케줄링에 각 프로세스가 CPU를 사용할 수 있는 시간인 `타임 슬라이스` 개념이 추가된 방식이다. 

각 프로세스는 정해진 타임 슬라이스만큼 CPU를 사용할 수 있고, 작업이 끝나지 않아도 주어진 타임 슬라이스가 다 지나면 문맥 교환이 일어나고 교체되는 선점형 스케줄링 방식이다.

타임 슬라이스 크기를 잘 정하는 것이 중요하다. 너무 크면 비효율적으로 기다리는 시간이 길 수도 있고, 너무 짧으면 잦은 문맥교환으로 인한 오버헤드의 위험성이 있다.

### 최소 잔여시간 우선 스케줄링(Shortest-Remaining-Time Scheduling)

위의 두 가지 스케줄링 방식을 합친 방식으로, 타임 슬라이스가 지난 프로세스가 그대로 뒤에 삽입되는 것이 아니라 잔여시간이 짧은 순으로 그 뒤에 대기하는 방식이다.

### 우선순위 스케줄링(Priority Scheduling)

프로세스들에 우선순위를 부여하고, 이 우선순위대로 실행하는 스케줄링 방식이다. 우선순위가 같은 프로세스 간에는 선입 선처리된다. 

SJF 스케줄링, SRT 스케줄링의 경우 이 우선순위 스케줄링에 해당한다. 해당 우선순위는 각각 작업시간과 잔여시간이 되겠다.

그러나 우선순위 스케줄링 방식은 근본적으로 우선순위에 밀려난 프로세스가 한없이 밀려난다는 `기아(starvation)`문제에서 벗어날 수 없다. 이를 방지하기 위해 `에이징(aging)` 기법 등을 사용하는데, 이는 오랫동안 대기한 프로세스를 나이를 먹이듯이 우선순위를 올리는 방식이다. 

### 다단계 큐 스케줄링(Multilevel Queue Scheduling)

준비 큐를 다단계로 만들어 이 큐 역시 우선순위에 차등을 두는  방식이다. 우선순위 스케줄링의 발전된 형태다. 

이 경우 최상위 큐에서부터 하나씩 프로세스를 처리하고, 최상위 큐가 비어 있으면 그 다음 큐에서 우선순위가 가장 높은 프로세스부터 실행한다.

타임 슬라이스를 다양하게 설정한다던지, 큐마다 다른 스케줄링 알고리즘을 사용할 수 있다는 장점이 있다. 단, 이 경우에도 근본적으로 최상위 큐를 비울 때까지 먼저 실행한다는 점에서 `기아`가 발생할 수 있다.

### 다단계 피드백 큐 스케줄링(Multilevel Feedback Queue Scheduling)

다단계 큐 간의 이동이 이루어지는 스케줄링 방식이다. 새로 준비상태가 된 프로세스는 우선 최상위 큐에 삽입되고, 일정 시간 실행되고 나서 실행이 마쳐지지 않으면 그 다음엔 차상위 큐에서 대기하게 된다. 그리고 이를 반복한다. 

타임 슬라이스를 많이 차지하는 CPU 집중 프로세스의 경우, 자연스럽게 우선순위가 낮은 큐로 밀려나게 된다. 또한 낮은 우선순위 큐에서 너무 오래 기다리고 있는 프로세스가 있다면, 이를 점차 높은 큐로 이동시키는 `에이징` 기법 역시 동일하게 적용되어 기아를 방지하기도 한다. 

가장 구현이 복잡하지만, 가장 일반적인 CPU 스케줄링 알고리즘으로 사용된다.