# 20240115_TIL - 입출력장치

## 입출력장치를 연결하는 통로 - 장치 컨트롤러, 장치 드라이버

현재까지 배운 하드웨어들로 우리가 아는 컴퓨터를 모두 구성할 수 있을까? 아니다. 외부에서 우리가 컴퓨터에게 명령을 입력하고 컴퓨터의 처리 결과를 볼 수 있어야 한다. 이런 외부 장치들이 컴퓨터 내부와 소통하기 위해서는 `장치 컨트롤러`와 `장치 드라이버`가 필요하다. 

참고로 여기에서 말하는 입출력장치에는 보조기억장치도 포함된다. 보조기억장치가 컴퓨터 내부와 소통하는 방식 또한 크게 다르지 않기 때문이다.

### 컨트롤러와 드라이버가 필요한 이유

입출력장치는 CPU와 메모리에 비해 더 다루기가 까다롭다.

먼저, `종류가 너무 많다`. 키보드, 마우스, 모니터, usb 등.. 장치가 이렇게 다양하면 다 장치마다 데이터 전송 방식도, 전송 속도도 다를 수 밖에 없다. 이를 규격화하기는 쉽지 않다.

그리고 `CPU와 메모리의 데이터 전송률에 비해 입출력장치의 데이터 전송률은 현저히 낮다`. CPU나 메모리는 1초에도 수많은 데이터를 주고 받을 수 있지만, 키보드와 마우스는 상대적으로 훨씬 적은 데이터를 주고 받는다. 이런 전송률의 차이는 입출력 장치와 내부 하드웨어 사이의 통신을 어렵게 한다.

### 장치 컨트롤러

입출력장치는 컴퓨터에 직접 연결되는 것이 아니라 `장치 컨트롤러(aka 입출력 제어기, 입출력 모듈)`를 통해 연결된다. 모든 입출력장치는 각자의 장치 컨트롤러를 통해 컴퓨터 내부와 정보를 주고받고, 장치 컨트롤러는 하나 이상의 입출력장치와 연결되어 있다.

장치 컨트롤러는 CPU와 입출력장치간의 번역가 역할을 해서 `정보를 규격화` 시키고, 그 과정에서 입출력 장치에 문제가 없는지 `오류 검출` 역할을 한다. 또한 `버퍼(buffer)`라는 임시 공간에 데이터를 저장해 송출 속도를 맞추는 방식을 통해 전송률 차이를 극복하는 `데이터 버퍼링` 기능을 제공한다.

### 장치 컨트롤러의 주요 부품

장치 컨트롤러 내부는 복잡하지만 그 중 중요한 역할을 하는 부품은 `데이터 레지스터`와 `상태 레지스터`, `제어 레지스터`가 있다. 

`데이터 레지스터`는 CPU와 입출력장치 사이에 주고 받을 데이터가 담기는 레지스터로, 데이터 버퍼링을 위한 임시공간 `버퍼`의 역할을 한다. 주고 받는 데이터가 많은 입출력장치에서는 레지스터 다신 RAM을 사용하기도 한다. 

`상태 레지스터`는 입출력장치가 작업을 할 준비가 되었는지, 입출력 작업이 완료되었는지, 오류가 있는지 등의 상태 정보를 저장한다. `제어 레지스터`는 입출력장치가 수행할 내용에 대한 제어 정보와 명령을 저장한다. 이 두 레지스터는 하나의 레지스터로 사용되기도 한다.

### 장치 드라이버

컨트롤러가 입출력장치를 연결하기 위한 ‘하드웨어’라면, 장치 드라이버는 입출력장치를 연결하기 위한 ‘소프트웨어’다.

`장치 드라이버`는 새로운 장치를 컴퓨터에 설치하기 위해서 필요하다. 장치 컨트롤러의 동작을 감지하고 제어한다. 장치 컨트롤러가 내부와 정보를 주고 받게 해주는 프로그램이다. 

컴퓨터가 연결된 드라이버를 읽고 실행시킬 수 있다면, 그 입출력 장치는 컴퓨터 내부와 정보를 주고 받을 수 있다. 참고로 이 드라이버를 읽고 실행시키는 주체는 운영체제다. 

## 다양한 입출력 방법

그럼 장치 컨트롤러는 컴퓨터 내부에 어떤 식으로 정보를 입력하고 받아와서 출력할까? 가장 보편적인 입출력 방법으로는 `프로그램 입출력`과 `인터럽트 기반 입출력`, `DMA 입출력`이 있다. 

### 프로그램 입출력

프로그램 속 명령어로 입출력장치를 제어하는 방식이다. CPU가 명령어를 불러오다가 입출력 명령어를 만나면 입출력장치에 연결된 연결 컨트롤러와 상호작용하면서 입출력 작업을 수행한다.

예를 들어서 `메모리에 있는 내용을 하드디스크에 저장한다`는 신호를 보낸다고 생각해보자.

1. 하드디스크 장비 컨트롤러에 출력(데이터 쓰기)하라는 제어 신호를 보낸다. 그 후 디스크가 준비되었는지 주기적으로 상태 레지스터를 체크한다.
2. 장비 컨트롤러가 디스크 상태를 확인한다. 가능해지면 상태 레지스터에 가능하다고 표시한다.
3. 저장할 데이터가 장비 컨트롤러의 데이터 레지스터에 저장된다. 디스크에 쓰기 작업이 끝나면 종료된다.

근데 여기서 중요한 점이 있다. 이런 작업은 CPU가 입출력장치 컨트롤러의 정확한 위치를 알고 있기 때문에 가능하다. 어떻게 CPU는 이 정보를 알고 있을까?

- `메모리 맵 입출력(memory-mapped I/O)`
    
    메모리에 접근하기 위한 주소 공간과 입출력장치에 접근하기 위한 주소 공간을 하나의 주소 공간에 합쳐서 표현하는 방법이다. 예를 들어 0~1023번지까지 저장 가능한 주소 공간에 511번지까지는 메모리의 주소를 가리키고, 1023번지까지는 입출력장치의 컨트롤러 내 레지스터의 주소를 가리키는 것이다. 
    
    그렇게 되면 CPU는 이전에 우리가 공부한 내용대로 그냥 지정된 주소로 명령을 내리기만 하면 된다. 즉 명령어의 종류가 메모리와 입출력장치로 가는 곳이 다르다고 해서 생김새가 달라질 필요가 없다.
    
- `고립형 입출력(Isolated I/O)`
    
    반대로 메모리와 입출력장치에 접근하기 위한 주소 공간이 따로 분리된 방식이다. 만약 제어 버스 내에 차선이 2개가 있고, 하나는 메모리로, 하나는 입출력장치로 간다고 해보자. 그럼 명령이이 ‘입출력장치의 xx번지’ 등으로 표시된다면 명령어는 맞는 차선을 타고 올바른 방향으로 갈 것이다.
    

### 인터럽트 기반 입출력

인터럽트에 대해 배울 때 인터럽트는 외부의 입출력 등으로 발생할 수 있다고 했다. 이를 `인터럽트 기반 입출력`이라고 한다. 이 방식에서 입출력 명령을 처리하는 주체가 바로 입출력장치의 장치 컨트롤러다.

CPU는 장치 컨트롤러에게 입출력 작업을 맡기고, 장치 컨트롤러로부터 인터럽트 요청 신호가 오는 지를 기다리면서 명령어 실행을 마칠 때마다 체크한다. 이후 인터럽트 요청 신호가 들어오면 입출력 관련 ISR을 실행시키고 이를 처리한다. 

- `풀링(pooling)`
    
    인터럽트와 자주 비교되는 개념 중 하나로, 프로그램 입출력처럼 CPU가 주기적으로 입출력장치의 상태와 처리할 데이터의 유무를 확인하는 방식이다. CPU가 계속 주체적으로 확인해야 하므로 부담이 더 크다. 
    

근데 우리가 사용하는 입출력장치는 하나만이 아니다. 만약 여러 입출력장치에서 동시에 입출력 인터럽트 요청이 들어오면 어떻게 될까?

우선 간단하게 들어온 대로 ISR을 실행하는 방식이 있다. 그러나 이 경우에는 인터럽트의 우선순위를 파악할 수 없다. 그래서 많은 컴퓨터들은 `PIC(Progammable Interrupt Controller)`라는 하드웨어를 사용한다. PIC는 여러 장치 컨트롤러와 연결되어 인터럽트 요청들의 우선순위를 판단하고, CPU에게 가장 먼저 처리해야 할 하드웨어 인터럽트부터 알려준다.

1. PIC가 하드웨어 인터럽트들을 받아들인다.
2. 인터럽트 우선순위를 판단하고 일단 인터럽트 요청 신호 보낸다.
3. CPU는 요청 신호를 받고 다시 확인 신호를 PIC에게 보낸다.
4. PIC는 데이터 버스를 통해 인터럽트 벡터를 보내 실행시켜야 할 서비스 루틴을 알려준다.
5. CPU는 인터럽트 벡터를 통해 알맞은 ISR을 실행한다.

참고로 컴퓨터들은 다양한 하드웨어 인터럽트를 처리하기 위해 2개 이상의 PIC를 함께 사용한다. 그리고 PIC는 `NMI(Non-Maskable Interrupt)`를 제외한, 인터럽트 비트를 통해 막을 수 있는 인터럽트만 관리한다.

### DMA(Direct Memory Access) 입출력

위 2가지 입출력방식은 메모리와 입출력장치를 거치는 모든 데이터 이동을 CPU가 주도한다는 공통점이 있다. 그런데 입출력장치와 메모리를 이동하는 데이터가 모두 CPU를 거친다면 안 그래도 바쁜 CPU는 시간을 빼앗긴다.

그래서 입출력장치가 CPU를 거치지 않고 메모리와 상호작용할 수 있는 방식인 `DMA 입출력`이 있다. 이를 위해서는 시스템 버스에 연결된 `DMA 컨트롤러`라는 하드웨어가 필요하다.

과정은 다음과 같다.

1. CPU는 DMA 컨트롤러에 입출력장치의 주소와 수행할 연산, 읽고 쓸 메모리의 주소 같은 정보를 전달해서 입출력 작업을 명령한다.
2. DMA 컨트롤러는 CPU를 대신해 장치 컨트롤러와 소통한다. DMA 컨트롤러는 필요한 경우 메모리에 직접 접근해 정보를 읽고 쓴다.
3. 입출력 작업이 끈타면 DMA 컨트롤러가 CPU에 인터럽트를 걸어서 작업이 끝났다고 알린다.

간단하게 말해서 CPU가 입출력 과정에 대해 DMA 컨트롤러에게 대리를 맡기고 보고만 받는 것이다.

단 이런 방식에는 생각해야 할 점이 하나 있다. 바로 시스템 버스를 사용한다는 점인데, 시스템 버스는 동시에 사용될 수 없다. 따라서 CPU가 다른 연산을 하면서 시스템 버스를 사용한다면, DMA 컨트롤러는 사용이 불가능하고 반대도 마찬가지다.

그래서 DMA 컨트롤러는 CPU가 시스템 버스를 사용하지 않을 때 잠깐 사용하거나, CPU에게 일시적으로 사용하지 말아달라는 허가를 구하고 시스템 버스를 사용한다. CPU 입장에서는 버스에 접근하는 주기를 빼앗기는 상황이므로 이를 `사이클 스틸링`이라고도 한다.

- `입출력 버스`
    
    CPU, 메모리, DMA 컨트롤러, 장치 컨트롤러가 모두 같은 버스를 공유하게 되면 CPU가 시스템 버스를 이용하지 못하는 빈도가 그만큼 많아질 수밖에 없다. 그래서 입출력 버스라는 별도의 버스를 만들어 DMA 컨트롤러와 장치 컨트롤러가 정보를 주고 받게 하는 방식이 있다. 
    
    현대 대부분의 컴퓨터는 입출력 버스가 존재하고, 대부분의 입출력장치는 입출력 버스를 통해 컴퓨터 내부와 연결되어 있다. 
    
    최근에는 아예 입출력 버스를 따로 두는 것을 넘어 입출력 전용 CPU를 두는 컴퓨터도 존재한다. 이 경우 DMA 컨트롤러가 하는 일을 별개의 CPU가 한다고 생각하면 된다.