# 20240108_TIL - 주소 지정 방식, ALU와 제어장치

## 주소 지정 방식

> 명령어의 오퍼랜드에는 데이터 또는 유효 주소, 그리고 다시 한 번 데이터를 담고 있거나 주소를 가리키는 레지스터 이름이 들어간다.
> 

### Recap + Intro

명령어의 오퍼랜드 필드는 피연산자 혹은 사용될 피연산자를 담고 있는 메모리나 레지스터의 주소를 담기도 한다. 그래서 오퍼랜드를 `주소 필드`라고 부르기도 한다.

근데 어차피 해당하는 피연산자를 가리키는 주소를 넣을 거면, 그냥 그 연산자를 가리키면 되는 게 아닌가? 왜 굳이 주소값을 넣어서 한 번 더 거치는 과정을 가질까?

이는 명령어가 가질 수 있는 길이가 한정되기 때문이다.

### 즉시 주소 지정 방식

n-주소 명령어처럼 n개의 피연산자가 들어가는 경우, 이 n개의 명령어를 연산코드를 제외한 필드를 나눠서 담아야 하므로 필요한 공간이 급격하게 줄어든다. 즉 `한 주소 필드 내에서 표현 가능한 수`만큼만 표현할 수 있을 뿐이다. 이런 방식을 `즉시 주소 지정 방식`이라고 한다. `즉시 주소 지정 방식`은 연산 데이터를 찾아가는 과정이 없으므로 비교적 속도가 빠르다.

### 직접 주소 지정 방식

하나의 명령어가 64비트라고 가정해보자. 만약 연산코드가 차지하는 길이가 4비트라고 하면, 남은 60비트의 공간을 활용해서 명령어에 사용할 피연산자를 표현해야 한다.  

그런데 주소를 담게 되면, `해당 주소가 가리키는 주소에 담을 수 있는 데이터 수`만큼 표현할 수 있다. 이렇게 연산에 사용될 데이터의 위치를 오퍼랜드에 명시하는 경우를 `직접 주소 지정 방식`이라고 한다. 그러나 이 방식 역시 표현해야 할 피연산자가 많은 경우에는 그만큼 가리킬 수 있는 공간이 제한되는 것은 마찬가지다.

### 간접 주소 지정 방식

오퍼랜드에 주소를 입력하되, 타고 가는 곳에 바로 데이터가 있는 것이 아니라 또 다른 유효주소를 설정해 두 번의 링크를 타고 데이터로 접근하는 방식이 있다. 이를 `간접 주소 지정 방식`이라고 한다. 이 방법은 오롯이 메모리 주소 하나를 모두 주소를 가리키는 데 사용할 수 있으므로, 담을 수 있는 정보의 수는 `한 메모리 주소를 통으로 사용해 표현할 수 있는 데이터 수`가 된다. 그만큼 메모리를 두 번 참조하는 시간이 있으므로 속도는 느리다.

### 레지스터 (간접) 주소 지정 방식

잠시 리마인드 해보자면, 연산에 사용될 데이터가 레지스터에 저장된 경우도 있다. 일반적으로 CPU 내부에 있는 레지스터에 있는 데이터를 불러오는 것이 더 빠르므로, 위에 언급했던 `직접 주소 방식`에 의해 가져오는 것보다 더 속도가 빠르다. 

이 때 레지스터가 바로 데이터를 가지고 있는 것이 아니라 또 다른 유효 주소를 가리키는 경우가 있다. `간접 주소 지정 방식`과 유사하지만 메모리를 참조하는 시간이 한 번이므로(레지스터를 찍고 가는 건 cpu 내부니까) 비교적 더 빠르다.

위 내용을 정리하면 다음과 같다.

- `즉시 주소 지정`: 연산될 데이터
- `직접 주소 지정`: 연산될 데이터가 저장된 메모리 내 유효 주소
- `간접 주소 지정`: 연산될 데이터의 메모리 내 유효 주소의 주소
- `레지스터 주소 지정 방식`: 연산될 데이터가 저장된 레지스터 이름
- `레지스터 간접 주소 지정 방식`: 유효한 데이터의 메모리 내 유효 주소가 저장된 레지스터 이름

## ALU와 제어장치

### ALU

> `ALU`는 계산기다. 수행할 연산은 `제어장치`를 통해서 `제어 신호`를 입력받고, 피연산자는 `레지스터`에서 받는다.
> 

연산의 결과는 데이터거나 메모리 주소가 될 수 있다. 명령어의 실행 결과는 프로세스의 정보이므로 메모리에 저장되어야 한다. 

그러나 모든 연산마다 일일이 메모리에 접근하게 되면 CPU 외부로 나가 메모리에 접근해야 하는 시간이 많아지고, 그럴 수록 성능 이슈가 발생한다. 그렇기 때문에 우선 계산 결과를 `레지스터`에 잠시 저장 후 전송한다.

연산의 결과물은 데이터나 메모리 주소 외에 `플래그`가 존재한다. 이는 결과에 대한 추가적인 정보를 담고 있다. 

- 부호 플래그: 음수면 1
- 제로 플래그: 값이 0이면 1
- 캐리 플래그: 사칙 연산 과정에서 올림 수나 빌림 수가 발생하면 1
- 오버플로우 플래그: 발생 시 1
- 인터럽트 플래그: 가능 시 1(인터럽트가 무엇인지는 후술)
- 슈퍼바이저 플래그: 커널 모드 시 1, 사용자 모드 시 0(이것이 무엇인지는 운영체제 파트에서)

이런 값들은 `플래그 레지스터`에 저장된다.

이 밖에도 ALU 내에는 계산을 위한 여러 `회로`들이 있다. 이는 따로 공부를 해야 하는 부분이지만 일단은 넘어가자.

### 제어장치

> CPU 내부/외부와 정보를 주고 받고, 명령어를 해석한다. CPU의 구성요소 중 가장 정교하게 설계되는 부품이다.
> 

받아들이는 정보를 먼저 살펴보자. 우선 `클럭 신호`를 받아들인다. `클럭(clock)`은 제어장치 및 CPU를 비롯한 컴퓨터의 부품들이 동작하는 시간의 단위를 말한다. 메트로놈이라고 생각하자.

제어장치가 명령어를 해석하려면 우선 해석할 명령어를 받아와야 한다. `명령어 레지스터`에서 가져올 수 있다. 또한 해석한 명령어를 읽는데 참고해야 할 `플래그` 정보 역시 `플래그 레지스터`에서 받아온다.

내보내는 정보는 크게 `CPU 내부로 보내는 제어 신호`와 `CPU 외부로 보내는 제어 신호`가 있다. CPU 내부로 가는 신호는 ALU와 레지스터로 향하며, 외부로 가는 신호는 시스템 버스를 거쳐야 하므로 곧 `제어 버스`로 보내는 것을 의미한다. 데이터 읽기/쓰기를 위해 `메모리`로 가거나 시스템 외부로 결과를 전송하기 위해 `입출력장치`로 향한다.