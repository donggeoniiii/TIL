# 20240117_TIL - Recap(메모리, 입출력장치), 운영체제를 알아야 하는 이유

## 메모리(주기억장치)

### RAM의 특징과 종류

- RAM과 ROM이 있지만, 우리가 흔히 이야기 하는 메모리는 RAM을 말한다.
- 실행 중인 프로그램이 실행하는 데 필요한 명령어와 데이터가 들어간다. 전부가 들어가는 건 아니다.
    - RAM의 용량이 클수록 보조기억장치에서 복사해와야 하는 횟수가 줄어들기 때문으로 어느정도 용량이 커지는 것은 성능적으로 유리하다.
- RAM의 종류는 S(Static)RAM, D(Dynamic)RAM, S(Synchronized)DRAM, DDR(Double Data Rate) SDRAM 등이 있다.
    - DRAM은 동적으로 메모리에 저장된 내용을 지우기 때문에 지우지 않는 SRAM에 비해 속도는 느리지만, DRAM이 더 소형화와 대량 생산에 유리하다. 둘이 쓰임새가 다르다.

### 메모리의 주소 공간

- `물리 주소`: 메모리가 사용한다. 데이터가 저장되어 있는 실제 주소를 말한다.
- `논리 주소`: 실행 중인 프로그램과 CPU가 사용한다. 실행되고 있는 프로그램 내에서 상대적인 주소를 말한다.
- CPU와 메모리 사이에서 주소를 변환시켜주는 `MMU(Memory Management Unit)`라는 하드웨어가 존재한다. CPU가 사용하는 논리 주소를 메모리가 이해할 수 있는 물리 주소로 변환시켜준다.
- 변환 과정에서 엉뚱한 물리 주소를 가리키지 않도록 `베이스 레지스터`와 `한계 레지스터`가 각각 담고 있는 프로그램의 물리주소 시작점과 주소 범위를 사용해서 벗어날 경우 예외를 발생시킨다.

### 캐시 메모리

- 저장 장치 계층 구조: CPU에 가까울수록 속도가 빠르고 저장 공간은 작다. 대신 비싸다.
`레지스터` - `캐시 메모리(L1 L2 L3 순)` - `메모리` - `보조기억장치`
- 메모리에서 사용되는 메모리는 `참조 지역성의 원리`에 따라 최근에 참조된 주소나 데이터, 또는 그 주변의 데이터를 갖고 있는다. 이를 `캐시 메모리`라고 한다.
    - 캐시 메모리는 일반적으로 L1, L2, L3로 나뉘고, 그 중 L1과 L2 메모리는 보통 코어 내부에 있다.
    - L1 캐시 메모리는 L1D, L1I로 나누어서 각각 데이터와 명령어만 담고 있기도 하다.

## 보조기억장치

### 다양한 보조기억장치

- 하드디스크: 자기적인 방식으로 저장하고 지운다. 자성을 잃으면 저장이 안된다.
    - 데이터를 가져와서
- 플래시 메모리: 전기적인 방식으로 저장하고 지운다. 마찬가지로 영구적인 방법은 아니다.
    - SSD, SD카드, USB 등

### RAID의 정의와 종류

- RAID는 여러 개의 보조 기억 장치를 하나의 논리적인 장치로 사용하는 방법이다.
- RAID 방식은 0~6과 이를 조합한 10, 50 등이 있다.
    - RAID 0: 전체 장치에 파티션을 나누어 저장
    - RAID 1: 전체 장치의 절반에 원본, 나머지 절반에 복사본 저장해서 복구하도록 설계
    - RAID 4: 전체 장치 중 하나를 분리해 패리티비트를 이용한 오류 검출 및 복구 역할로 사용
    - RAID 5: 전체 장치에 대해 일부분을 패리티비트를 통한 오류 검출 및 복구를 위해 사용하도록 설계
    - RAID 6: 패리티 비트를 두 가지 경우로 저장해서 검수. 5 버전에 비해 더 확실하게 안정성을 부여할 때 사용

## 입출력장치

### 장치 컨트롤러와 장치 드라이버

- 입출력장치와 컴퓨터 내부 (CPU 등)는 전송률이나 데이터 처리 속도에 있어서 차이를 가진다. 그렇기 때문에 원활한 데이터 송수신을 위해서 `장치 컨트롤러`와 `장치 드라이버`가 역할한다.
- `장치 컨트롤러`는 하드웨어로 데이터 전송량을 맞춰주는 역할을 하고, 입출력과 관련된 인터럽트를 발생시킨다.
`장치 드라이버`는 소프트웨어로 장치 컨트롤러가 컴퓨터 내부와 정보를 주고 받을 수 있게 해준다. 이를 실행시키는 주체는 운영체제다.
- 장치 드라이버는 운영체제가 갖고 있기도 하고, 장치 제작자가 따로 제공하기도 한다.

### 다양한 입출력 방법

- `프로그램 입출력`: CPU가 입출력 명령어를 실행시키면 입출력 명령을 실행한다.
    - CPU가 명령어를 읽으면 입출력장치가 실행 가능한 상태인지를 주기적으로 살펴야 한다.
    CPU에게 부담이 가는 방식이다.
    - `메모리 맵(memory-mapped) 입출력`: 명령어 내 주소 공간을 반으로 나누어 입출력장치의 컨트롤러 주소와 메모리 주소를 동시에 표현하는 방법이다. 표현 가능한 주소 공간이 줄어들지만 명령 방식은 달라지지 않는다.
    - `고립형(Isolated) 입출력`: 입출력 장치로 향하는 명령과 메모리로 향하는 명령어가 분리되어 있다. 주소 공간을 온전히 주소 표현에 사용할 수 있지만 명령 방식이 달라야 한다. 이 경우 제어 버스에서 통로가 나뉘게 된다.
- `인터럽트 입출력`: CPU가 인터럽트 승인 요청을 받으면 `ISR`을 실행시키는 방식으로 입출력 명령을 해결한다. CPU가 부담을 덜 갖는 방식이다.
- `DMA 입출력`: `DMA 레지스터`라는 하드웨어에게 CPU가 입출력 명령을 하청을 맡긴다. CPU는 DMA 레지스터의 업무 종료 신호만 수신한다.
    - DMA가 입출력명령을 처리하려면 CPU와 동일하게 시스템 버스를 사용해야 한다. 동시에 사용할 수 없기 때문에 CPU가 DMA의 사용 여부를 확인해야 한다.
    - 이를 처리하기 위해 `입출력 버스`를 별개로 나누어 사용한다.

<br>

## 운영체제를 알아야 하는 이유

컴퓨터는 전기만 공급한다고 작동하는 것이 아니다. 이를 작동시키기 위한 프로그램이 존재하고, 컴퓨터 내부는 이 프로그램의 명령을 따른다. 이 특별한 프로그램이 바로 `운영체제(Operating System`이다.

### 운영체제가 하는 일

컴퓨터 프로그램이 작동하기 위해서는 컴퓨터가 가지고 있는 스펙 중 일부를 사용해야 한다. 여기서 컴퓨터 프로그램 작동에 필요한 요소를 `자원`이라고 표현한다. 지금까지 컴퓨터구조에서 배운 CPU, 메모리, 입출력장치 등이 여기에 해당한다.

`운영체제`는 실행할 프로그램에 필요한 자원을 할당하고, 올바르게 실행되도록 돕는 특별한 프로그램이다. DRAM에서 동적으로 프로세스에 메모리를 할당하고 해제하는 주체가 바로 이 운영체제가 되겠다. 또한 메모리에 올라간 프로세스 간에 CPU를 공정하게 사용하도록 한다.

프로그램의 범주에 포함되는 만큼 역시 메모리에 올라가야 실행된다. 다만 특별한 프로그램이라서 컴퓨터가 부팅될 때 메모리 내 `커널 영역`이라는 완전히 다른 영역에서 실행된다. 참고로 우리가 지금까지 이야기 했던 메모리 내 영역은 `사용자 영역`에 해당한다.

비유를 하자면 운영체제는 중앙정부가 국가에서 하는 역할과 비슷하다. 정부 내 부처가 매우 다양한 것처럼, 운영체제 역시 내부에 CPU, 메모리 등 담당하는 영역이 나누어져 있다.

### 운영체제를 왜 공부해야 할까?

운영체제가 없다면, 개발자가 프로그램을 작동시키기 위한 하드웨어 명령을 모두 처리해야 한다. 그렇지만 현실에서는 운영체제가 이를 담당해주기 때문에 개발자는 보다 높은 수준의 코드를 작성하는데 집중할 수 있다.

다만 운영체제가 일을 어떻게 하는 지는 알아둘 필요가 있다. 프로그램 실행 중 하드웨어 상에 문제가 발생한다면, 운영체제는 우리보다 더 하드웨어에 대한 정보를 많이 알고 있다. 예를 들어, 메모리 누수 등의 문제로 인해 오류가 발생할 때 이 오류 메시지의 근원 역시 운영체제다. 

또한 운영체제는 프로그램이므로 개발자가 하드웨어에 비해 더 접근성이 높다. 

즉, 운영체제에 대한 이해가 높을 수록 개발자는 업무에 있어 문제해결 역량을 갖출 수 있게 된다. 그리고 결과적으로 하드웨어와 프로그램 양쪽에 대한 깊은 이해를 얻을 수 있다.

## 운영체제의 큰 그림

### 커널(Kernel)

운영체제는 존재하는 현존하는 프로그램 중 규모가 가장 큰 프로그램 중 하나다. 모든 기능이 중요하지만, 그 중 가장 중요한 기능은 프로그램이 올바르고 안전하게 실행되고 공정하게 자원을 할당받게 하는 기능이다. 이를 담당하는 부분을 `커널(Kernel)`이라고 한다. 

운영체제가 설치된 모든 기기는 이 커널이 존재한다. 커널의 종류가 무엇인지에 따라 개발하는 프로그램이 하드웨어를 이용하는 양상이 달라지고, 성능에도 영향을 미친다. 앞으로 이야기 하는 운영체제는 모두 이 커널 부분을 해당한다.

### 커널에 해당하지 않는 운영체제 기능 - 사용자 인터페이스

사용자 인터페이스(UI)는 사용자가 컴퓨터와 상호작용할 수 있는 통로로, 당연히 `사용자 영역`에 해당하는 기능이다. 바탕화면을 생각하면 된다.

- `그래픽 사용자 인터페이스(GUI)`: 바탕화면 클릭클릭
- `커맨드 라인 인터페이스(CLI)`: cmd창으로 내리는 명령

### 이중모드와 시스템 호출

운영체제는 철저하게 일반 응용 프로그램을 자원과 분리시켜 자원을 보호한다. 자원의 문지기가 되는 셈이다. 응용 프로그램이 자원에 접근하려면 운영체제에게 요청을 보내야 한다. 이는 곧 운영체제의 코드를 실행하는 것을 의미한다.

운영체제가 응용 프로그램의 요청을 수락하면, 운영체제는 응용 프로그램 대신 자원에 접근해서 요청한 작업을 수행한다. 예를 들어 워드프로세서에서 작업한 문서를 저장장치에 저장하려면, 운영체제가 커널 영역 내의 SSD에 문서를 저장하는 코드를 실행해 대신 처리한다.

이렇게 CPU가 운영체제의 도움을 받아 명령을 처리하는 방식을 `커널 모드`라고 하고, 운영체제의 도움을 받지 않는 방식을 `사용자 모드`라고 한다. 이렇게 두 방식으로 나누어 CPU가 응용 프로그램의 명령어를 처리하는 것을 `이중 모드`라고 한다. 

사용자 모드에서는 응용 프로그램이 시스템 자원에 접근할 수 없다. 따라서 CPU는 자원에 접근해야 할 때 운영체제 서비스를 위해 모드 변경을 요청해야 하는데 이를 `시스템 호출(System Call)`이라고 한다. 

이 시스템 호출은 일종의 인터럽트로, 하드웨어에 의해 발생되는 것이 아니라 시스템을 호출하는 특정 명령어에 의해 발생하므로 `소프트웨어 인터럽트`라고 표현한다. 이를 처리하는 과정은 하드웨어 인터럽트와 유사하다. ISR이 커널 영역에서 실행되고 다시 원래대로 돌아와서 원래 작업이 실행된다.

다시 워드 프로세서에서 SSD에 작성중인 문서를 저장하는 상황이라고 생각해보자.

1. 워드에서 저장 버튼을 누른다. CPU가 이 명령어를 사용자 모드에서 읽는다.
2. 저장 명령은 SSD라는 시스템 자원을 사용해야 하기 때문에 시스템 호출을 발생시킨다.
3. 시스템 호출에 의해 소프트웨어 인터럽트가 발생한다. 지금까지 처리된 작업을 잠시 스택에 저장해 두었다가 커널 영역에서 저장 명령을 처리한다.
4. 다시 사용자 모드로 돌아온다. 임시저장한 작업을 다시 처리한다.

일반적으로 응용 프로그램은 실행 과정에서 이런 서비스를 매우 빈번하게 이용한다(우리가 저장을 몇 번 누르는 지 생각해보자).

### 운영체제의 핵심 서비스

운영체제의 핵심 서비스 중 `프로세스 관리`, `자원 접근 및 할당`, `파일 시스템 관리`를 살펴보자.

- `프로세스 관리`
    
    하나의 CPU는 프로세스 중 단 하나만 실행시킬 수 있다. 그렇기 때문에 실제 컴퓨터 내부에서는 수많은 프로세스를 번갈아가며 실행한다. 이때 프로세스마다 사용하는 자원과 그 상태가 다양하기 때문에, 이를 잘 관리해주어야 한다.
    
- `자원 접근 및 할당`
    
    모든 프로세스는 자원을 할당받아야 실행될 수 있다. 운영체제는 프로세스가 사용할 자원에 접근하고 조작함으로써 이 필요한 자원을 할당한다.
    
    - CPU: 프로세스별로 CPU를 사용할 순서와 시간을 조정해준다(`CPU 스케줄링`).
    - 메모리: 같은 프로세스라도 실행할 때마다 적재되는 주소가 달라진다. 운영체제는 프로세스가 적재될 때마다 어떤 주소에 적재할 지를 결정하고, 메모리가 부족할 때는 이를 극복하기 위한 방법을 찾아서 실행한다.
    - 입출력장치: ISR은 운영체제가 제공하는 기능으로, 커널 모드에서 실행될 수 있다. 운영체제는 ISR을 제공함으로써 입출력 과정에 관여한다.
- `파일 시스템 관리`
    
    우리가 컴퓨터를 사용할 때는 다양한 파일을 열고, 생성하고, 삭제한다. 그리고 이 파일들을 묶어 하나의 경로에 보관해서 관리하기도 한다. 이런 당연해 보이는 파일 시스템을 제공하는 주체는 바로 운영체제다.
    

### 가상머신

위에서 운영체제는 커널 모드와 사용자 모드의 이중 모드를 제공한다고 했지만, 사실 현대의 CPU는 `가상 머신(Virtual Machine)`을 이용해 두 가지 모드 이상을 지원한다.

가상 머신은 소프트웨어적으로 만들어낸 논리적인 가상의 컴퓨터다. 가상 머신을 설치하면 새로운 운영체제와 응용 프로그램을 그 위에서 설치하고 실행할 수 있다. 

이 때 가상 머신 역시 하나의 프로그램이기 때문에, 한 운영체제 위에서 사용자 모드로 작동된다. 따라서 이 가상 머신 내에서 설치된 응용 프로그램이 커널에서 제공하는 운영체제 서비스를 이용하기 위해서는 방식이 바뀌어야 한다.

그래서 가상 머신을 지원하는 CPU는 이를 위한 `하이퍼바이저(Hypervisor) 모드`를 제공한다. 이 때 가상 머신 상에서 작동하는 응용 프로그램은 가상 머신에 설치된 운영체제로부터 운영체제 서비스를 받을 수 있다.