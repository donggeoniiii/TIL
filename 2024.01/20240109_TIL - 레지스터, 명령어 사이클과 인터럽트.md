# 20240109_TIL - 레지스터, 명령어 사이클과 인터럽트

## 레지스터

명령어와 데이터는 실행 전후로 레지스터에 저장된다. 따라서 레지스터에 저장되는 값을 보면 프로그램이 실행되는 흐름을 볼 수 있다. 레지스터는 맡은 역할에 따라 다양한 종류로 나뉜다.

### 레지스터의 종류

현재 우리가 사용 중인 CPU 내에 있는 레지스터는 종류가 아주 다양하다. 그 중 대부분의 CPU가 공통으로 포함하는 레지스터의 종류는 다음과 같다.

- `프로그램 카운터(aka 명령어 포인터)`: 메모리에서 읽어올 명령어의 주소. 값을 불러오고 나면 다음 주소를 가리킨다.
- `명령어 레지스터`: 방금 메모리에서 읽어온 명령어 저장. 제어 장치가 읽고 제어 신호를 보낸다.
- `메모리 주소 레지스터`: 메모리의 주소 저장. CPU가 메모리에 저장하기 전에 잠시 거칠 때 주소는 여기에 저장되었다가 주소 버스로 옮겨진다.
- `메모리 버퍼 레지스터`: 메모리에 쓰려고 하거나 전달받은 값(데이터) 저장.
- `플래그 레지스터`: ALU가 연산한 결과나 CPU 상태의 부가정보를 저장한다.
- `범용 레지스터`: 프리롤을 맡는다. 데이터와 주소를 모두 저장할 수 있다. 일반적으로 여러개의 범용 레지스터가 존재한다.
- `스택 포인터`: 스택의 `top`을 가리키는 레지스터. 즉 마지막으로 넣은 값의 위치를 가리킨다.
- `베이스 레지스터`: 기준 주소의 역할을 하는 레지스터. 오퍼랜드에서 저장하고 있는 주소까지 거리를 이용해 주소 지정 방식에 사용한다.

### 레지스터를 통해 CPU가 연산하기까지

1. `프로그램 카운터`가 불러올 값이 저장된 메모리 주소를 가리키고 있다.
2. 제어장치가 주소 버스를 통해 프로그램 카운터 상에 저장된 주소로, 제어 버스를 통해 메모리 읽기 제어 신호를 보낸다.
3. 메모리에서 읽어온 값이 `메모리 버퍼 레지스터`에 데이터 버스를 타고 저장된다. `프로그램 카운터`가 다음 주소를 가리킨다.
4. 읽어온 값이 `명령어 레지스터`로 이동된다. 제어장치가 이를 읽고 제어 신호를 발생시킨다.

### 특정 레지스터를 이용한 주소 지정 방식

- `스택 주소 지정 방식`: 메모리 내에서 사용하는 스택 영역을 통한 주소 지정 방식. LIFO 방식으로 주소를 가리키게 된다.
- `변위 주소 지정 방식`: 오퍼랜드에 있는 데이터 값과 특정 레지스터의 값을 더해 유효 주소를 찾는 방식.
    - `상대 주소 지정 방식`: 오퍼랜드와 `프로그램 카운터`의 값을 더한다. 오퍼랜드 필드에 있는 값에서 프로그램 카운터만큼 이동한 주소값만큼 이동하라는 뜻이다.
    - `베이스 레지스터 주소 지정 방식`: 오퍼랜드와 `베이스 레지스터`의 값을 더한다. 가변하는 프로그램 카운터와 다르게 기준이 고정되어 있다. 베이스 레지스터의 값을 기준으로 오퍼랜드에 저장된 주소값만큼 이동하여 찾으라는 뜻이다.

## 명령어 사이클과 인터럽트

CPU가 하나의 명령어를 처리하는 과정은 정해진 흐름이 있고, CPU는 이 흐름을 반복한다. 이를 `명령어 사이클`이라고 한다. 그리고 간혹 이 흐름이 끊어지는 상황이 발생할 수 있다. 이를 `인터럽트`라고 한다.

### 명령어 사이클

크게 명령어를 가져오는 과정과 실행하는 과정으로 나뉜다. 각각 `인출 사이클`과 `실행 사이클`이라고 한다. 

`인출 사이클`은 제어장치가 여러가지 주소 지정 방식을 통해 주소값을 받아와서 메모리에서 실행할 값을 가져온 후, `명령어 레지스터`에 저장하는 과정까지를 말한다. 

`실행 사이클`은 이를 제어 장치가 읽고 해석해서 제어 신호를 발생시키는 단계까지 해당한다. 이후 다시 인출 사이클로 이어진다. 

대부분의 명령어는 인출 사이클과 실행 사이클이 반복되면서 일어난다. 그런데 주소 지정 방식에 따라 값에 접근하기까지 메모리 접근이 2번 필요한 경우가 있다. 이 경우 첫 번째 메모리 접근으로 얻은 주소값을 통해 다시 한 번 메모리에 접근하여 인출할 값을 가져오는 과정이 추가된다. 이를 `간접 사이클`이라고 한다.

하지만 이것만으로는 명령어 사이클의 모든 것을 설명할 수 없다.

### 인터럽트

CPU가 명령어를 실행하는 과정은 방해를 받아 잠시 중단될 수 있는데, 이렇게 CPU를 방해하는 신호를 `인터럽트`라고 한다. 업무를 보는 중에 ‘긴급!’이 붙어있는 메일을 받고 잠시 다른 일을 먼저 처리하는 것을 생각하면 된다. 이 경우 긴급 메일이 `인터럽트`에 해당한다.

### 인터럽트의 종류

인터럽트를 발생시키는 주체가 누구인지에 따라 `동기 인터럽트`와 `비동기 인터럽트`로 나뉜다. 

- `동기 인터럽트`: CPU에 의해 발생하는 인터럽트. 프로세스에서 프로그래밍 상의 오류 같은 `예외` 상황이 발생했을 때 발생한다. 그렇다. 그 `예외`다. 보통 그래서 `예외`라고 부른다.
- `비동기 인터럽트`: 입출력 장치에 의해 발생하는 인터럽트. CPU에게 알림 역할을 한다. 예를 들어서 아이디와 패스워드를 입력하고 나서 로그인을 위한 인증과정을 거쳐야 할 때, 입력을 마쳤다는 의미로 로그인 버튼을 입력하면 입출력장치가 CPU에게 완료 알림을 보낸다. 
보통 인터럽트를 말하면 대부분 이 비동기 인터럽트를 말하지만, 헷갈리는 것을 방지하기 위해 이를 `하드웨어 인터럽트`라고 한다.
입출력장치의 경우 CPU에 비해 속도가 너무 느리기 때문에, CPU가 입출력장치가 하는 일을 기다리게 되면 CPU의 사이클이 낭비된다. 인터럽트는 CPU가 입출력장치가 일하는 동안 다른 일을 처리하고 오도록 해준다.

### 하드웨어 인터럽트의 처리 순서

지금까지의 기록에서 대부분 언급했던 것처럼, 하드웨어 인터럽트의 처리 과정도 CPU의 종류에 따라 다 다르다. 

1. 입출력장치가 CPU에 `인터럽트 요청 신호`를 보낸다. 
2. CPU는 실행 사이클이 끝날 때마다 명령어를 인출하는 과정을 시작하기 전에 인터럽트 여부를 확인한다.
    1. CPU가 인터럽트 요청을 확인하면 `플래그 레지스터`의 `인터럽트 플래그`를 통해 인터럽트를 받아들일 수 있는 상황인지 확인한다.
    2. 다만 모든 인터럽트를 플래그를 통해 막을 수 있는 것은 아니다. 무시할 수 없는 하드웨어 인터럽트의 경우(정전이나 하드웨어 고장 등) 인터럽트가 실행된다.
3. 인터럽트를 받아들일 수 있다면 
    1. 현재까지 작업을 백업한다.(어디에?)
    2. `인터럽트 벡터`를 참조해 `인터럽트 서비스 루틴(ISR)`을 실행한다.
4. `인터럽트 서비스 루틴`이 실행을 마치면 백업된 작업을 다시 복구해 인출 사이클로 넘어간다.
위와 같은 과정을 `인터럽트 사이클`이라고 한다.

`인터럽트 서비스 루틴`은 `인터럽트 핸들러`라고도 하며, 인터럽트를 처리하는 프로그램이다. 해당 인터럽트가 발생할 경우 처리하는 정보가 담긴 매뉴얼이다. 이 역시 하나의 프로그램이므로 명령어와 데이터로 이루어져 있고 똑같은 과정을 거쳐 실행된다.

인터럽트의 종류가 여러가지이므로 ISR 역시 여러 종류가 있다. CPU는 이를 구분하고 인터럽트 종류에 맞는 서비스 루틴을 실행시켜야 한다. 이를 위해 `인터럽트 벡터`를 사용한다. 인터럽트 벡터를 알면 CPU는 각 ISR의 시작 주소를 알 수 있고, 이를 통해 특정 ISR을 처음부터 실행시킬 수 있다. 

그럼 ISR 실행을 위해 이전 작업을 백업하는 과정은 어떻게 될까? 위에서 배웠던 `스택 주소 지정 방식`을 여기서 사용한다. 메모리의 스택 영역에 지금까지 작업 내용을 보관하고, ISR이 끝나면 다시 스택에서 불러와서 사용한다. 

정리하자면, 명령어 사이클은 기본적으로 `인출 사이클`과 `실행 사이클`의 반복으로 이어진다. 그 중 메모리 접근이 한 번으로 끝나지 않는 경우 `간접 사이클`이 추가될 수 있고, 인터럽트가 발생하면 작업된 내용을 백업 후 ISR을 실행하고 돌아오는 `인터럽트 사이클`이 추가될 수 있다.

## (참고) 예외의 종류

CPU가 본래 하던 작업으로 돌아왔을 때 발생한 명령어와 그 다음 명령어부터 실행하느냐에 따라 `폴트(fault)`와 `트랩(trap)`으로 나뉜다. 

`폴트`는 예외가 발생하면 이를 처리하고 다시 예외가 발생한 명령어부터 실행한다. 예를 들어, 프로세스 실행에 필요한 데이터가 메모리에 없는 경우, CPU는 `폴트`를 발생시키고 보조기억장치에서 필요한 데이터를 가져온다.

`트랩`은 예외가 발생하면 이를 처리하고 그 다음 명령어부터 실행한다. 예를 들어 디버깅하는 경우에는 특정 코드가 실행되면 `트랩`을 발생시켜 잠시 원래 프로그램의 실행을 멈추고, 이 때의 프로그램 상태를 보여준다.

때로는 CPU가 프로세스를 강제로 중단시킬 수밖에 없는 심각한 오류를 발견할 때가 있다. 이 때는 `중단(abort)`를 발생시켜 프로세스를 강제 중단시킨다.

이 밖에도 입출력 장치가 아니라 시스템 호출로 인해 발생하는 `소프트웨어 인터럽트`가 존재한다. 이는 운영체제를 공부하고 다시 알아보자.