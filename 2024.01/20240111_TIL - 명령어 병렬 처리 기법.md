# 20240111_TIL - 명령어 병렬 처리 기법

## Recap

CPU가 좋은 성능을 내기 위해서는 클럭 속도를 올리고, 여러 개의 코어와 스레드를 지원하는 것도 방법이다. 하지만 이 방법이 다는 아니다. CPU가 얼마나 일을 효율적으로, 쉬는 시간을 최소로 한 채 작동하는지도 성능에 중요한 영향을 미친다. 여기에는 CPU를 쉬지 않고 돌리는 `명령어 병렬 처리 기법`들이 존재한다.

## 명령어 파이프라인

CPU가 명령어를 처리하는 과정을 순서대로 써보자.

1. 명령어 인출
2. 명령어 해석
3. 명령어 실행
4. 결과 저장

그런데 여기서 이 네 과정을 잘 살펴보면, 이 모든 과정이 각자 다른 부분에서 일어난다는 것을 알 수 있다. 인출과 저장은 레지스터와 CPU 밖 메모리의 각자 다른 필드(일반적으로는)에서 일어날 것이고, 명령어 해석은 제어장치가 하며 실행은 ALU에서 담당한다. 

즉, 이 과정이 겹치지만 않는다면 CPU는 각 단계를 동시에도 실행이 가능하다는 이야기다.

이렇게 명령어를 처리하는 일련의 과정을 `명령어 파이프라인`이라고 하고, 동시에 여러 개의 서로 다른 단계에 존재하는 명령어를 실행하는 것을 `명령어 파이프라이닝`이라고 한다. 

명령어 파이프라이닝은 높은 성능을 보장한다. 그렇지만 이러한 방식은 큰 위험성이 존재한다.

### 데이터 위험

만약 A와 B라는 두 명령어 간에 ‘A 이후 B’라는 선후 관계가 존재한다고 가정해보자. 그렇다면 이 두 명령어는 명령어 파이프라이닝 방법으로 실행될 수 있을까? 아니다. 왜냐하면 A의 실행결과가 나오지 않으면 B의 정상 실행 여부를 장담할 수 없기 때문이다.

이렇게 두 명령어 사이에 데이터 의존성이 존재할 때, 명령어 파이프라이닝이 제대로 작동하지 않는 것을 `데이터 위험`이라고 한다.

### 제어 위험

만약 명령어의 실행 결과가 분기성을 가진다고 하자. 일단 프로그램 카운터는 자연스럽게 증가하면서 명령어 파이프라이닝으로 자연스럽게 다음 주소의 명령어를 가지고 온다. 그런데 이전 명령어의 실행 결과에 따라 이어지는 주소의 명령어가 아니라, 아예 다른 명령어를 실행시켜야 할 수도 있다. 이렇게 되면 처리 중이던 명령어가 의미가 없어지고, 이 동안 CPU의 작업은 불필요한 것이 된다.

이렇게 프로세스의 흐름이 바뀌어 프로그램 카운터 값에 갑작스러운 변화가 생기게 되어 처리 중이었던 명령어들이 쓸모가 없어지는 것을 `제어 위험`이라고 한다. 이를 방지하기 위해 분기 주소를 미리 예측해서 인출하는 `분기 예측` 등의 기술을 통해 그 주소를 인출한다. 어떻게 하는 지는 더 알아봐야겠다.

### 구조적 위험

서로 다른 명령어가 동시에 ALU나 동일한 레지스터 등 같은 CPU 부품을 사용하려고 할 때 문제가 발생할 수 있다. 이를 `구조적 위험`, 또는 `자원 위험`이라고 한다.

## 슈퍼 스칼라

현대의 CPU 중 대부분은 명령어 파이프라인이 한 개 뿐만이 아니다. 이렇게 내부에 여러 개의 명령어 파이프라인을 가지고 있는 구조를 `슈퍼 스칼라`라고 하고, 이를 지원하는 CPU를 `슈퍼 스칼라 프로세서(CPU)`라고 한다. 보통 멀티코어, 멀티스레드 프로세서가 여러 개의 레지스터 세트와 ALU 등을 가지고 있어 슈퍼스칼라 구조를 사용할 수 있다.

이론적으로 사용 가능한 파이프라인 개수에 비례해 처리 속도가 빨라진다. 그렇지만 실제 작동 시에는 위에 말했던 위험들이 존재하기 때문에 약간의 성능 저하가 발생한다. 또한 여러 개의 파이프라인을 위험 없이 관리하기는 어렵기 때문에 정교한 설계가 필요하다.

## 비순차적 명령어 처리(OoOE)

명령어 파이프라인이 다음과 같은 흐름을 가진다고 가정하고, 위에서 언급했던 네 과정 중 하나 하나가 1 클럭의 시간이 걸린다고 가정하자.

```java
1) O(1) <- 1 입력 // 1 ~ 4클럭
2) O(2) <- 2 입력 // 2 ~ 5클럭
3) O(A) <- O(1) + O(2) 입력 // *5 ~ 8클럭
4) O(5) <- 5 입력 // 6 ~ 9클럭
5) O(7) <- 7 입력 // 7 ~ 10클럭
```

여기서 3은 1과 2의 실행이 모두 끝나야 실행될 수 있는 명령어이다. 하지만 4와 5는 1, 2, 3의 결과에 의존성을 갖지 않는다. 그렇지만 3이 의존성을 가지기 때문에 어쩔 수 없이 대기하는 시간이 생긴다. 

`비순차적 명령어 처리` 기법은 명령어를 순차적으로 실행하지 않고, 데이터 의존성이 없는 명령어를 먼저 실행하여 파이프라인이 멈추는 것을 방지하는 기법이다. 위의 경우에는 다음과 같다.

```java
1) O(1) <- 1 입력 // 1 ~ 4클럭
2) O(2) <- 2 입력 // 2 ~ 5클럭
3) O(5) <- 5 입력 // 3 ~ 6클럭
4) O(7) <- 7 입력 // 4 ~ 7클럭
5) O(A) <- O(1) + O(2) 입력 // 5 ~ 8클럭
```

이를 위해선 CPU가 명령어 간의 데이터 의존성을 판단하고, 순서를 바꿔서 실행할 수 있는지를 판단할 수 있어야 한다. 현대의 CPU의 성능 향상에 크게 기여한 기법으로, 대부분이 채택하고 있다. 

## CISC와 RISC

CPU가 명령어 파이프라이닝과 이를 비롯한 슈퍼스칼라, 비순차적 명령어 처리 기법을 사용하려면 CPU도 중요하지만 명령어 역시 파이프라이닝에 최적화되어 있어야 한다. 파이프라이닝에 최적화된 명령어는 어떤 구조를 가지고 있을까?

### ISA

`ISA(Instruction Set Architecture)`는 한 CPU가 이해할 수 있는 명령어들의 모음, `명령어 집합`을 말한다. 앞에서 말한 것처럼 CPU마다 명령어의 생김새와 작동 원리는 조금씩 차이가 있다. ISA가 다른 경우 한 컴퓨터에서 만든 프로그램을 다른 CPU를 사용하는 컴퓨터에서 실행하면 작동하지 않는다. 즉 소스코드가 같아도 이를 변환해서 실행할 명령어의 생김새가 같아야 한다는 것이다. 

참고로 이는 소스코드를 변환하는 컴파일러에 따라서도 명령어(정확히는 어셈블리어)가 달라질 수 있다. 이 경우 역시 실행이 제대로 되지 않을 것이다.

ISA는 곧 이 소프트웨어가 작동하는 방식을 정해놓은 교본이고, CPU를 비롯해서 이 소프트웨어를 작동시킬 하드웨어 역시 이런 교본에 맞게 설계되어 있다. 

### CISC

`CISC(Complex Instruction Set Computer)`는 복잡한 ISA를 활용하는 컴퓨터라는 뜻으로, 명령어의 형태와 크기가 다양한 가변 길이 명령어를 활용한다. 

메모리에 접근하는 주소 지정 방식이 다양하고, 명령어의 종류가 많으므로 상대적으로 적은 수의 명령어로도 구체적인 표현이 가능하다. 그러므로 메모리 크기에 한계가 있는 환경에서 장점이 있는 방식이다.

단, 활용하는 명령어가 워낙 복잡하고 다양한 탓에 한 명령어를 실행시키는 데 시간이 일정하지 않고 여러 클럭 주기를 필요로 한다. 이는 명령어 실행을 규격화 하기 어렵다는 것이고, 파이프라이닝을 원활하게 적용시키기 어렵다는 말과 같다.

또한, 다양한 명령어를 가지고 있다지만 주로 사용되는 명령어는 그렇게 많지 않다. 이는 비효율적인 설계를 가지고 있다는 것과 같다.

 

### RISC

`RISC(Reduced Instruction Set Computer)`는 고정 길이 명령어를 활용하는 컴퓨터들로, 길이가 고정되어 있으므로 명령어가 규격화 되어 있다. 또한 1클럭 내외로 실행되는 명령어를 지향해 처리 속도가 빠르다. 명령어 파이프라이닝에 보다 최적화된 방식이다. 다만 표현에 사용되는 명령어 개수 및 길이는 상대적으로 많고 길다.

또한 메모리에 집적 접근하는 명령어를 단 두 개(`load`, `store`)로 제한해 메모리 접근을 단순화하고 최소화했다. 이런 점에서 RISC를 다른 말로 `load-store`구조 라고도 한다. 메모리를 자주 방문하지 않는 만큼 레지스터를 적극적으로 활용한다. 이를 수용하기 위해서는 프리롤을 맞는 범용 레지스터 역시 많다.