# 20240129_TIL - 프로세스 동기화 기법

앞서서 프로세스의 동기화의 중요성에 대해서 배웠고, 이를 위해 공유 자원에는 동시에 여러 개의 프로세스가 접근해서는 안 된다. 동기화 기법에는 여러 가지 종류가 있다. 

## 뮤텍스 락

임계구역에 대한 동기화를 위해 탈의실 문제를 예시로 들어보자. 

- 옷 가게에 원하는 옷이 있으면 손님은 탈의실에 들어가서 옷을 입어볼 수 있다.
- 탈의실엔 당연히 한 번에 한 명만 들어갈 수 있다.
- 여기서 `손님`은 `프로세스`, 공동으로 사용하며 한 시점에선 단 한 명만 접근하는 `탈의실`은 `임계 구역`이라고 하자.
- 만약 밖에서 처음 온 사람이 온다면, 탈의실에 사람이 있는지 없는지 알 수 있는 방법이 있을까?

이런 상황에서 우리는 `자물쇠 또는 도어락을 건다`는 해결책을 낼 수 있다. 

- 밖에서 손님이 문을 열려고 시도했을 때 잠겨 있다면 사용 중, 아니면 비어 있는 상태다.

이를 코드로 구현한 것이 바로 `뮤텍스 락(mutex lock)`이다. 임계 구역에 진입하는 프로세스는 뮤텍스 락을 이용해 내가 사용 중임을 알리는 자물쇠를 걸고, 다른 프로세스는 임계 구역이 잠겨 있다면 기다리고, 잠겨 있지 않다면 임계 구역에 진입할 수 있다.

### 뮤텍스 락의 구현 형태

뮤텍스 락은 단순하게 이런 형태로 구현된다.

```java
static boolean lock; // 자물쇠 역할을 하는 전역 변수

acquire() { // 작업 시작 전 임계 구역을 잠근다. 이미 잠겨 있다면 열릴 때까지 계속 확인한다.
	while (lock == true) {
		return; 
	}
	
	lock = true;
}

release() { // 임계 구역의 잠금을 해제한다. 임계 구역의 작업이 끝나면 호출한다.  
	lock = true;
}
```

프로세스는 이런 형태의 뮤텍스 락을 통해 락을 획득할 때까지 주기로 확인하며, 획득하면 작업을 진행하고 마치면 락을 푸는 과정을 거친다.

한편 C/C++, 파이썬 등의 프로그래밍 언어는 사용자가 직접 구현할 필요 없이 이미 뮤텍스 락을 구현해 놓았다. 

## 세마포어

`세마포어(semaphore)`는 공유자원이 여러 개 있는 상황에서도 적용이 가능한 동기화 도구이다.

위의 탈의실 문제에서, 탈의실이 하나가 아니라 여러 개인 상황이라고 생각해보자. 그럼 위와 같은 자물쇠가 없어도 되는 걸까? 그렇지 않다. 여전히 탈의실은 공동으로 사용하는 공간이고, 각각의 탈의실 여부는 밖에서 확인할 수 있어야 한다.

실제 프로세스와 공유 자원의 개념에서 바라보면, 한 컴퓨터에 3개의 프린터를 연결해서 사용하고 있다고 생각할 수 있다. 이 때 역시 모든 프로세스가 3개의 프린터를 모두 공유하며 사용할 수 있지만, 하나의 프린터를 사용할 수 있는 프로세스는 하나 뿐이다. 그러므로 이에 대한 락 기능을 모두 제공해야 한다.

### 카운팅 세마포어의 구현 형태

세마포어의 종류에는 `이진 세마포어`와 `카운팅 세마포어`가 있다. 이 중 이진 세마포어는 뮤텍스 락과 유사하므로 카운팅 세마포어에 대해 더 살펴보자.

- 세마포어는 철도 신호기에서 유래한 단어다. 기차는 신호기가 GO라고 되어 있으면 통과 가능한 것으로 간주하고 이동하고, STOP이라고 되어 있으면 멈춘다.
- 세마포어 역시 두 개의 함수와 하나의 변수를 통해 임계 구역에 들어가도 좋은지, 기다려야 하는지를 보여준다.

```java
static int S; // 임계 구역에 접근할 수 있는 프로세스의 수 == 비어 있는 공동 자원의 수

wait() { // 사용할 수 있는 자원이 있는 지 반복적으로 확인한다. 
	while (S <= 0) { // 다 사용 중이라면 기다린다.
		return; 
	}
	
	S--; // 사용 가능한 자원이 있다면 사용할 수 있는 자원의 수를 1 감소시키고 실행한다.
}

signal() { // 임계 구역에서의 작업을 마치고 사용할 수 있는 자원의 수를 1 증가시킨다.  
	S++;
}
```

근데 여기선 한 가지 문제가 있다. 이는 뮤텍스 락도 마찬가진데, 이렇게 작동하면 결국 CPU가 주기적으로 공동 자원에 접근 가능한지 여부를 확인해야 한다. 분명 CPU 주기를 낭비하는 일이다.

그래서 세마포어는 다음과 같은 방식을 사용한다.

```java
static int S; // 사용 가능한 공유 자원의 수

static Queue<PCB> waitingQueue; // 세마포어 대기 큐

wait() {
	S--; // 일단 사용할 거라고 감소 시켜본다
	if (S < 0) { // 어? 남은 자리가 없었네?
		waitingQueue.offer(curProcess.pcb); // 일단 대기 큐에 PCB를 추가한다
		sleep(curProcess); // 해당 프로세스 대기모드로 전환
	}
}

signal() {
	S++; // 작업이 끝났으니까 여기 비었다고 알려준다
	if (S <= 0) { // 어? 한 자리 빼줬는데 빈 자리가 없는 상태면 기다리는 애가 있겠네?
		PCB p = waitingQueue.poll(); // 대기 큐에서 하나 빼온다
		wakeup(p); // 해당 프로세스 실행모드로 전환
	}
}
```

이를 이용하면 상호 배제를 위한 동기화뿐만 아니라, 실행 순서 제어를 위한 동기화도 만족시킬 수 있다. 세마포의 변수를 0으로 두고 먼저 실행할 프로세스 뒤에 signal 함수를 배치하고, 나중에 실행할 프로세스 앞에 wait를 두면 어떤 프로세스가 먼저 실행되더라도 두 개의 프로세스가 원하는 순서대로 실행이 가능하다.

## 모니터

세마포어 역시 훌륭한 동기화 도구지만, 사용하기가 조금 불편하다. 일일이 임계구역 앞 뒤로 wait와 signal 함수를 배치해야 하기도 하고, 여기서 실수가 발생하면 예기치 못한 결과를 얻을 수도 있다. `모니터(monitor)`는 이런 실수를 방지하기 위해 최근에 등장한 동기화 도구다. 

아까 들었던 탈의실 문제의 연장선이다. 손님이 탈의실에 접근하려고 할 때 직원이 와서 현재 사용 가능 여부를 알려주면 좋지 않을까? 그리고 뒤에 대기하는 손님들도 직원에게 확인을 받고 접근하면, 직접 문을 열어볼 필요도 없지 않을까?

### 인터페이스

모니터는 공유 자원을 관리하기 위해 `인터페이스`를 사용한다. 인터페이스는 공유자원과 프로세스를 연결하는 통로의 역할을 한다.

- 프로세스는 반드시 인터페이스를 통해서만 공유 자원에 접근하도록 한다.
- 공유 자원에 접근하고자 하는 프로세스는 큐에 삽입되고, 큐에 삽입된 순서대로 인터페이스를 통해 공유 자원에 접근한다.
- 모니터 안에는 항상 하나의 프로세스만 존재한다. 이를 통해 상호 배제의 동기화가 보장된다.
- 모니터는 실행 순서 제어를 위한 동기화도 제공한다. 이를 위해서 특정 조건을 나타내는 `조건 변수`를 사용한다.

```java
wait() {
	// 호출된 프로세스의 상태를 대기 상태로 전환
	// 일시적으로 조건 변수에 대한 대기 큐에 삽입(!! 인터페이스 진입 대기 큐와 다름 !!)
	// 다른 프로세스의 signal 연산을 통해 실행이 재개된다.
}

signal() {
	// wait를 호출한다. 큐에 삽입된 프로세스의 실행을 재개시킨다.
	// 해당 조건 변수에 의해 대기상태에 있던 프로세스가 인터페이스를 통해 실행된다.
}

```

- 특정 프로세스가 아직 실행될 조건이 되지 않으면 `wait`를 통해 실행을 중단한다.
- 특정 프로세스가 실행될 조건이 충족되면 `signal`을 통해 실행을 재개한다.