# 20240319_TIL - 네트워크 계층 (4), KMP 알고리즘

---

## 네트워크 계층(4)

### Recap: IP 데이터그램

IP 프로토콜에서 데이터를 전송하고 받는 단위. IP 패킷이라고 하지만 데이터그램이 좀 더 정확한 표현이다(패킷은 너무 일반적인 표현이라).

### ICMP(Internet Control Message Protocol)

네트워크 상에서 증상을 알기 위한 컨트롤 메시지를 운반하는 프로토콜이다. IP 데이터그을 처리할 때 발생하는 에러를 알려준다. 

보통 네트워크 진단을 위해 사용된다.

- 목적지의 호스트가 없다던지
- 목적지 포트 번호가 없다던지

이런 일이 발생하면 출발지 호스트에게 이를 알려준다.

코드로 정해져 있으며, 네트워크 계층의 IP 데이터그램에 포함된다.

### IPv6의 데이터 형태

IPv6는 고정된 40바이트의 헤더를 갖고 있으며 단편화가 불가능하다. 

- `priority`
    
    데이터 flow 안에서 데이터그램 간의 우선순위를 식별한다.
    
- `flow label`
    
    같은 flow 안에 있는 데이터그램을 식별한다.
    
- `next header`
    
    상위 계층 프로토콜이 무엇인지 표시한다(TCP/UDP)
    

### 터널링(Tunneling)

IPv4의 라우터에서 IPv6 데이터그램을 IPv4의 페이로드에 포함하는 방식. IPv4에서 IPv6로 넘어가는 현재 과도기에서 적용하는 방식이다. 

```java
-----------IPv4 헤더 정보-----------
|                                  |
|                                  |
-----------IPv4 페이로드------------	
|	-----IPv6 헤더 정보------   |
|	|      flow : X         |  |
|	|       src : A         |  |
|	|      dest : F         |  |
|	------------------------   |
----------------------------------
```

### 라우팅 알고리즘

- `Static vs Dynamic`
    - `static`
        - 관리자가 수동으로 경로를 입력한다.
        - 시간이 지나면서 경로가 느리게 바뀐다.
    - `dynamic`
        - 라우터가 상황에 따라 경로를 동적으로 결정한다.
        - 경로가 더 빨리 바뀐다. 라우팅 테이블이 정기적으로 업데이트 된다.
- `Global vs Decentralized Information`
    - `Global`
        - 라우터가 모든 연결 정보와 사용 비용을 안다.
        - 모든 노드가 자신의 링크 상태를 브로드캐스팅한다.
    - `Decentralized`
        - 라우터는 물리적인 이웃으로의 이동 비용만 알고 있다.
        - 이웃과 정보를 교환하는 반복 계산 과정을 거친다.
        - distance vector 알고리즘이 있다.

### Link-state 알고리즘

- 모든 노드의 경로 비용과 연결 정보를 알고 있으므로 다익스트라 알고리즘을 사용한다 (방식은 생략)
- 시작점에서 도착점까지 비용이 가장 적은 경로를 계산해 포워딩 테이블을 만든다.

### Distance vector 알고리즘

자기가 알고 있는 인접 라우터 정보를 vector로 보낸다고 해서 붙여진 이름이다. 

- 벨만-포드 알고리즘을 사용한다.
- 시작점부터 도착점까지 이웃 노드로의 비용만 알고 있으므로 재귀적으로 거리를 잰다.
- 라우터는 이웃 중 가장 비용이 적게 드는 인접 라우터 정보만 저장하고, 인접한 라우터가 가진 테이블 정보를 서로 교환하면서 각자 테이블을 갱신한다.
- 비동기적이고 반복적으로 변경이 발생한다.
    - 각 노드는 자신의 경로 비용이 변경되어 distance vector(이하 dv) 값이 변경될 때만 이를 전송한다.
    - 각 노드는 이웃으로부터 dv를 전송받은 경우에만 업데이트한다.

<br>

## 문자열: KMP 알고리즘

전체 문자열 길이가 N일 때 M 길이의 패턴은 어떻게 찾을까?

```java
boolean isExist(String sample, String key) {
	for (int sdx = 0; sdx < sample.length() - key.length() + 1; sdx++) {
		boolean match = true;
		for (int kdx = 0; kdx < key.length(); kdx++) {
			if (sample.charAt(sdx + kdx) != key.charAt(kdx)) {
				match = false;
				break;
			}
		}
		// 맞는 위치를 찾으면
		if (match) return true;
	}

	// 끝까지 못 찾으면 없는 것
	return false;
}
```

그러나 이 방식이면 최악의 경우 O(NXM)에 동작하면서 비효율적인 알고리즘이 된다. 

KMP 알고리즘은 이 패턴 매칭 문제를 O(N+M)에 해결하게 해주는 알고리즘이다. 이를 위해선 `실패함수`라는 개념을 이해해야 한다.

### 실패함수

> F(x) : 문자열 S[0:x+1]에서 자기 자신을 제외하고 접두사와 접미사가 일치하는 최대 길이
> 

```java
ex) S = ABA
A B A
A B A
-> 자기 자신 제외

A B A
  A B A
-> 일치하지 않음

A B A
    A B A
-> 일치
=> F(1) = 1
```

여기에서 다음과 같은 추론이 가능하다.

1. F(x) = y이라는 정보가 있다고 하자. 그럼 F(x+1)은 그 자리에서 바로 다음 문자열이 해당하는 지만 확인하면 된다(문자열의 길이도 하나 늘어나니까).
2. 그럼 F(x+1)은 다음 문자열이 해당하지 않으면 n, 해당하지 않으면 무조건 y+1일까? 정답은 그렇다. 이는 귀류법으로 증명 가능하다(F(x) = y일 수 없음).

정리하자면, F(x)는 최대 F(x-1) + 1이다. 그리고 F(x) = F(x-1) + 1인지를 확인하려면 S[x] = S[F(x-1)]인지 확인하면 된다.

근데 S[x] != S[F(x-1)]이면, F(x) = F(x-1)일까? 그건 또 아니다. 이 경우에는 하나씩 슬라이드 해보면서 겹치는 부분을 찾아야 한다.

F(x-1) = y일 때 F(x)인 부분을 비교하는 상황을 생각해보자. 

- 현재 앞뒤로 y개까지는 일치하고 있는 상태다.
- k개가 일치하지 않으면 y-1개가 일치하는 지점을 찾아야 한다. 즉, F(y-1)이 가리키는 값을 찾으면 된다.
- y = F(y-1)라고 하고 다시 y-1개가 일치하는 지점을 찾을 수 있다. 또 일치하지 않는다면? 그 다음 F(y-1)가 가리키는 지점을 찾아본다.

```java
// 실패 함수 구하기
void getFailure(String s) {
	int[] F = new int[s.length()];

	/* 
        원본의 index, 
        F(0) = 0임이 자명하므로(자기 자신이 같은 경우는 안보니까)
        1부터 비교하기 시작
	*/
	int i = 1;

	// 일치하는지 비교할 index
	int j = 0;
	
	while (i < s.length()) {
	
		// 일치하지 않으면 j = F[j-1]로 index 변
		while (j > 0 && s.charAt(i) != s.charAt(j)) {
			j = F[j-1];
		}
		
		// 일치하면 F[i-1] = j였으니까 F[i]에는 j+1 저장
		if (s.charAt(i) == s.charAt(j)) {
			F[i] = ++j;
		}
		
		// 만약 F[0] = 0일 때까지 와버리면 i를 한칸 옮겨서 진행
		i++;
	}
}
```

### 실패함수를 이용한 KMP 알고리즘

패턴 찾기 알고리즘의 의의는 결국 찾으려는 문자열이 저 안에 들어가 있는가?이다. 이를 실패함수 생성 알고리즘에 대입하면..

```java
int[]	F = new int[key.length()];

void failure(String key) {
	// ...
}
	
boolean isMatch(String s, String key) {
	// 일치하는지 비교할 index
	int j = 0;

	// 일치하는 패턴의 개수
	int patternCnt = 0;
	
	/*
	원본의 index,
	F(0) = 0임이 자명하므로(자기 자신이 같은 경우는 안보니까)
	1부터 비교하기 시작
	*/
	for (int i = 1; i <= s.length(); i++) {

		// 일치하지 않으면 j = F[j-1]로 index 변경
		while (j > 0 && s.charAt(i) != key.charAt(j)) {
			j = F[j-1];
		}

		// 일치하면 F[i-1] = j였으니까 F[i]에는 j+1 저장
		if (s.charAt(i) == key.charAt(j)) {
			j++;
		}

		// 만약 마지막 문자열까지 일치하는 지점을 찾으면 true
		if (j == key.length()) {
			return true;
		}

		// 만약 F[0] = 0일 때까지 와버리면 i를 한칸 옮겨서 진행
		i++;
	}

	// 없으면 false
	return false;
}

```