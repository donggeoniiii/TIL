# 20240329_TIL - 네트워크 보안 (2)

## SSL

HTTP는 TCP에 의존하는 어플리케이션 계층의 통신 프로토콜이다. 근데 TCP가 다 좋지만 보안기능은 제공을 안해준다.

`SSL(Secure Socket Layer)`, 혹은 `TLS(Transport Layer Security)`는 그런 TCP의 단점을 보완해주는 친구다. HTTP와 TCP 사이에서 전달될 메시지가 보안처리를 해주는 역할을 한다. `SSL`은 사용자 계층의 라이브러리로, TCP 소켓으로 전달될 메시지를 암호화 시켜서 내린다.

### HTTPS와 HTTP

간단하게 얘기해서 HTTP에서 TCP 소켓으로 바로 거치느냐, SSL을 거치느냐의 차이다. 간단하게도 아니고 그냥 이거다. 

### SSL 통신의 과정

1. TCP Connection을 맺는다. 
2. 서버의 공용키 인증서를 받는다.
3. 인증받은 공용키를 바탕으로 둘만의 master secret key를 암호화해서 보낸다.
    - 사용하는 master 비밀키는 4가지가 있다. 최초의 msk를 기반으로 만들고, 통신하는 내용에 따라 사용하는 비밀키가 달라진다.

### 메시지 무결성 검사

SSL은 별개의 계층으로 분리하지는 않지만 `레코드`라는 전송 단위를 가진다. 

- SSL은 메시지를 레코드로 만들어 TCP 소켓으로 내려보낸다.
- SSL 레코드는 헤더와 데이터, 그리고 무결성 검사를 위한 `MAC(Message Authentication Code)`이 달려있다.
- SSL 헤더에는 데이터의 컨텐츠 타입, SSL 버전, 그리고 길이가 들어간다.
- `MAC`은 해시 함수에 데이터를 넣어서 변환시킨 값이다.
    - 근데 raw data를 그대로 변환시키면 레코드가 탈취되었을 때 변형될 가능성이 있다.
    - 그래서 raw data 뒤에 아까 말했던 4가지 master 비밀키 중 하나를 붙여 변형시킨다.
    - 여기에 어태커의 장난질에 대항하기 위해 다음과 같은 부분을 고려한다.
        - 레코드가 순서가 바뀌어서 도착하는 경우에 대비해 data + mk 뒤에 레코드의 seq 넘버까지 붙인다.
        - 레코드가 다 도착하기도 전에 TCP FIN을 날려 전송이 완료된 척하는 경우에 대비해 마지막 레코드에만 1로, 나머진 0으로 type 코드를 붙인다.

## 방화벽

게이트웨이 라우터에서 한 조직의 내부망을 모니터링하고 필터링하는 디바이스다. 모니터링하고 필터링하는 기준은 네트워크 운영자가 결정한다.

계층 침범의 대표적인 경우다. 게이트웨이 라우터는 네트워크 계층에 속하므로 IP 패킷 이상을 볼 수 없는데, 포트 번호를 알아야 하는 경우엔 세그먼트 헤더까지 알아 보아야 한다.

### ACL

Action Control List의 약자. 방화벽이 작동하기 위한 매뉴얼이라고 보면 된다. 

- `action`: allow 와 deny로 나뉜다. 의미는 말 그대로다.
    
    지금부터 아래의 필드들은 이 action의 판단 기준 중 하나가 된다.
    
- `src address / dest address`: 들어오는 패킷 헤더의 정보.
- `protocol`: TCP, UDP, 혹은 둘 다
- `src port / dest port`: 패킷 내 세그먼트의 헤더에 있는 포트 번호 정보
- `flag bit`: ACK, SYN 등 패킷의 타입

방화벽은 ACL의 최상단 기준부터 우선 적용한다.

### Stateful Packet Filter

ACL대로 처리를 하다보면 말이 안되는 패킷들이 통과될 가능성이 있다(예를 들어 tcp 연결도 없는 상태에서 ack type의 패킷이 통과된다던지). 이런 경우를 방지하기 위한 방법이다.

Stateful한 패킷 필터는 모든 TCP 연결의 상태를 트래킹한다. 그래서 지금 들어온 패킷이 말이 되는 패킷인지 아닌지를 검증하는 방식이다.