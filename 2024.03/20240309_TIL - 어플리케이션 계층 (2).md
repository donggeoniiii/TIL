# 20240309_TIL - 어플리케이션 계층 (2)

## 어플리케이션 계층

### Reliable Data Transfer (RDT)

전송 계층의 TCP는 신뢰성이 높은 프로토콜로, 주고 받는 데이터의 유실을 허락하지 않는다. 그렇지만 하위 계층에서 이루어지는 통신은 그렇지 않다. 

이렇게 비신뢰적인 통신이 발생할 때는 `패킷 에러`와 `패킷 유실`이 발생할 수 있다. `에러`는 내용이 변경되는 경우, `유실`은 내용이 사라지는 경우다. 

이 두 가지를 잘 처리하면 신뢰성 있는 전송이 가능하다. 이를 관리하는 건 전송계층에서 한다.

### RDT Protocol

`RDT 프로토콜`이란 전송 계층에서 신뢰성 있는 통신이 이루어지도록 하기 위한 프로토콜을 말한다. 

그 중 RDT 1.0은 완벽하게 신뢰적인 채널에서의 데이터 전송을 가정한다. 따라서 패킷 에러도 패킷 유실도 없다. 다만 이런 상황은 비현실적이다.

### RDT 2.0

패킷 에러가 발생할 수 있는 채널에서의 데이터 전송을 가정한다. 유실되는 경우는 고려하지 않는다.

1. 전송자가 패킷을 보낸다
2. 패킷을 수신하면 피드백을 보낸다(받으면 ACK / 못 받으면 NAK)
3. 만약 NAK를 전송자가 받으면 전송자는 패킷을 재전송한다

송/수신자는 패킷 에러를 판단할 수 있어야 하므로 다음과 같은 기능이 필요하다.

- `에러 감지`
    
    패킷 헤더에 에러 여부를 판단하는 체크섬 비트를 통해 에러 여부를 판단한다.
    
- `피드백`
    
    ACK, NAK를 통해 수신자는 에러를 감지하면 전송자에게 에러 상황을 알린다.
    
- `재전송`
    
    전송자는 NAK를 피드백으로 받으면 패킷을 재전송한다. 
    

이렇게 재전송을 기반으로 한 신뢰성 있는 데이터 전송 프로토콜을 `ARQ(Automatic Repeat Request) 프로토콜`이라고 한다. 

한편 RDT 2.0의 경우 피드백을 기다리는 동안에는 상위 계층으로부터 데이터를 전달받을 수 없어 `전송 후 대기(Stop-and-Wait) 프로토콜`이라고 한다.

그러나 이 방식은 치명적인 문제가 있다. 만약 피드백이 손상된다면 어떻게 될까?

### RDT 2.1

만약 수신자가 패킷을 잘 받아서 ACK를 보냈는데 전송자가 잘 갔는지를 모르면, 전송자는 혹시 모르니까 패킷을 무조건 다시 보낸다. 

근데 이런 경우에 수신자는 새로 받은 패킷이 이전에 받은 패킷과 다른 패킷인지를 알 수 없다(체크섬은 멀쩡하다면). 이를 식별하기 위한 방법이 필요하다.

- `시퀀스 넘버(#)`
    
    패킷에 붙이는 번호다. 식별값으로 사용한다.
    

수신자는 시퀀스 넘버를 통해 중복패킷 여부를 검사할 수 있다. 중복 패킷인 경우 이를 폐기한다.

### RDT 2.2 - NAK-free Protocol

수신자는 패킷을 받으면 무조건 ACK만 보낸다. 다만 이 안에 가장 최근에 받은 정상 패킷의 시퀀스 넘버를 동봉한다. 

만약 이전 프로토콜에서 NAK를 받았을 상황이라면 전송자는 중복된 시퀀스 넘버의 ACK를 받게 된다. 그러면 다음 시퀀스 넘버에 해당하는 패킷을 보내면 된다.

### RDT 3.0

패킷 에러와 패킷 유실 전부를 처리하는 프로토콜이다.

전송자가 보낸 패킷이 유실되는 경우, 수신자는 아무것도 받지 못한다. 수신자로부터 피드백도 없는 상황이라면 전송자는 어떻게 대처해야 할까?

- `타이머`
    
    전송자는 패킷을 보내고 일정 시간이 지나도록 아무 응답이 없으면 문제가 생겼다고 판단하고 해당 패킷을 재전송한다.
    
    이 때 이 무응답인 상황을 `타임아웃`이라고 한다.
    

타이머의 시간을 어떻게 정할지는 알잘딱의 영역이다.

- 너무 짧으면 통신은 빠르지만 너무 잦은 통신으로 네트워크 오버헤드가 증가
- 너무 길면 실제 에러 발생 시 대응이 느려진다

만약 잘 전송이 됐는데 타이머가 다 돼서 타임아웃으로 중복패킷이 보내진다면? ACK에 있는 시퀀스넘버를 이용해 대응한다.

### 파이프라인 프로토콜

그럼 현재 사용하는 네트워크 통신의 표준은 RDT 3.0일까? 그렇지는 않다. 실제 세상에서 사용하는 TCP 등은 이거보다 훨씬 더 복잡한 방식을 사용한다(다만 기본 원칙은 비슷하다).

- 실제 세상에서는 보내야 할 패킷이 엄청 많다
- 패킷을 이렇게 하나씩 전송하면 ACK가 올 때까지 그 소켓은 다른 통신을 할 수 없어서 많은 낭비가 발생한다

그래서 이에 대응하기 위한 방안이 `파이프라인 프로토콜`이다. 패킷을 한 번에 대량 전송하고, 이에 대한 피드백도 대량으로 받는 방식이다. 이러면 패킷 낭비를 줄일 수 있다.

다만 이러면 수신자 입장에서는 혼란이 올 수 있다.

- 어떤 패킷을 먼저 처리하고, 피드백을 주어야 하지?

이를 해결하기 위해 `go-Back-N`, `Selective Repeat` 프로토콜 등을 사용한다. (다음에 계속)