# 20240311_TIL - 전송계층 (2)

## Recap

### 계층별 데이터 전송 단위

잠깐 떠올려보자면, 계층마다 데이터를 전송하는 단위가 다르다.

- 어플리케이션 계층: `메시지`
- 전송 계층: `세그먼트`
- 네트워크 계층: `패킷`
- 데이터 링크 계층: `프레임`

상위 계층의 전송 단위는 하위 계층 전송 단위의 데이터 영역으로 들어간다(멀티플렉싱).

### RTT

Round Trip Time, 한 세그먼트가 수신자에게 도착하고 그 피드백이 전송자에게 오기까지 걸리는 시간.

### 타임아웃

TCP는 타이머를 통해 데이터의 재전송 여부를 판단한다. 만약 타이머가 되도록 피드백이 오지 않으면 패킷이 유실됐다고 판단한다. 이를 `타임아웃`이라고 하고, 이 때는 해당 패킷을 재전송한다.

## TCP Overview

### TCP의 특징

- `Point-to-Point`
    
    하나의 TCP 연결은 프로세스 한 쌍의 한 소켓의 통신만 담당한다. 
    
- `Reliable`
    
    데이터는 신뢰성 있고 순서대로 전송되며, Byte Stream 단위로 전송된다.
    
- `Pipelined`
    
    파이프라이닝 방식으로 전송된다.
    
- `Send & Receive Buffers`
    
    모든 프로세스는 전송 버퍼와 수신 버퍼가 있어야 한다. 여기서 버퍼의 크기는 window size와 같다.
    
- `Full Duplex Data`
    
    TCP는 양방향 데이터 통신이다. 각 프로세스가 전송자도 되고 수신자도 된다.
    
- `Connection-oriented`
    
    말 그대로 연결 지향성을 가진다. 본격적으로 데이터를 주고 받기 전에 핸드셰이크를 통해 연결을 설정한다.
    
- `Flow-controlled`
    
    흐름 제어: 전송자는 수신자가 받을 수 있는 데이터의 양을 초과해서 보내지 않는다.
    
- `Congestion-controlled`
    
    혼잡 제어: 내부의 네트워크가 처리할 수 있을 만큼의 데이터만 전송한다.
    

### TCP의 세그먼트 구조

- `포트 넘버`
    
    (디)멀티플렉싱을 위한 출발지와 목적지의 식별값이다. 각각 16비트씩 32비트가 할당된다. 
    
- `시퀀스 넘버(#)`
    
    세그먼트 데이터의 첫 바이트의 Byte Stream 번호다. 
    
- `ACK 넘버`
    
    다음에 받을 세그먼트의 시퀀스 넘버다. 예를 들어 ‘ACK 10’은 다음에 받을 세그먼트 데이터가 10바이트부터 포함되어야 한다는 것을 의미한다.
    
    (주의) go-back-N의 Cumulative ACK와는 다르다!
    
- `체크섬`
    
    에러를 검출하기 위한 비트다.
    
- `수신 window`
    
    현재 수신자가 수신 가능한 바이트의 개수다. 즉 수신 버퍼의 남은 공간을 의미한다.
    

여기서 TCP의 특징 중 양방향 통신이 잘 드러난다. 상대방에게 줄 데이터의 시퀀스 넘버와 다음에 받을 시퀀스 넘버를 ACK 넘버로 가리키고 있다. 

이렇게 TCP에서는 서로가 ACK 피드백과 동시에 메시지를 보낼 수도 있다. 

### TCP에서 타임아웃과 RTT

타이머를 사용하는 경우 이 타이머가 터지는 시간을 결정하는 것이 매우 중요하다.

- 너무 짧으면 오버헤드가 발생한다.
- 너무 길면 유실에 대한 대응이 느려진다.

그래서 이를 보통 RTT를 기준으로 하는데, 모든 패킷의 RTT가 일정하지 않다는 문제가 있다. 패킷의 전송 시간은 전송되는 경로와 네트워크 혼잡으로 인한 큐잉 지연 등으로 얼마든지 달라질 수 있다.

따라서 지금까지 측정한 RTT값을 더해 평균을 낸 값을 대표값으로 사용한다. 이를 `Estimated RTT`라고 한다. 

### TCP의 신뢰할 수 있는 통신

- 파이프라인 방식 사용
- Cumulative ACK
    
    다음에 받을 시퀀스 넘버를 가리킴으로써 이전까지 데이터를 잘 받았음을 표현한다.
    
- 단일 타이머
    
    한번에 전송하는 패킷에 대해 하나의 타이머만 사용한다. 다만 TCP는 이 중 타임아웃이 발생한 세그먼트만 재전송한다.
    

### TCP 재전송 시나리오

1. ACK가 유실
    
    ACK가 오기 전 데이터를 버퍼 크기만큼 재전송한다. 
    
2. ACK가 전송되던 중 타임아웃 발생
    
    일단 타임아웃이 터졌으니 전송자는 해당 데이터에 대해 버퍼 크기만큼 재전송한다. 
    
    수신자는 시퀀스 넘버를 보고 중복된 패킷을 확인하고 폐기한다. 그리고 받아야 할 시퀀스 넘버를 담은 ACK를 보낸다. 
    
    전송자는 수신자가 보낸 ACK를 보고 이전 데이터를 잘 받았음을 확인하고, ACK에 해당하는 다음 데이터를 보낸다.
    
3. ACK가 유실, 근데 그 다음 ACK가 정상 도착
    
    수신자는 도착한 ACK의 시퀀스 넘버 이전까지 데이터는 전송에 잘못된게 없다고 판단하고 아무 것도 하지 않는다.
    

Q. 그럼 ACK를 계속 보낼때마다 받는게 의미가 없지 않나? 그냥 마지막 한번만 잘 보내면 되는거 아닌가? 

A. 그래서 TCP의 권고안을 보면, ACK를 바로바로 보내는 것이 아니라 일정시간 기다리고 보내기를 권장한다.

### 빠른 재전송

TCP는 타임아웃이 일어나야만 패킷의 유실을 판단할 수 있는 걸까? 정답은 아니다.

TCP는 데이터의 전송 순서가 보장되는 통신 방식이다. 따라서 이에 대한 ACK도 순차적으로 날아간다. 

만약 100바이트짜리 데이터를 1바이트씩 보낸다고 하면, 그 중 10번째 패킷이 유실되면 앞으로 90개의 패킷은 ACK10이 날아간다. 그럼 TCP는 중복된 ACK가 계속 들어오는 걸 보고 데이터가 유실되었음을 판단할 수 있겠다.

TCP는 이를 바탕으로 한 번 받은 ACK가 3번 더 중복 전달되는 경우, 즉 동일한 ACK가 4번 오는 경우 유실되었다고 판단하도록 권고한다.