# 20240310_TIL - 전송계층 (1)

## 파이프라인 프로토콜

파이프라인 프로토콜을 이용하면 대량의 패킷을 주고 받을 때 더 효과적인 방식으로 네트워크 통신이 가능하다. 그렇지만 수신자 입장에서는 어떤 패킷을 먼저 처리하고 피드백을 보내야 할 지가 어려워진다. 이를 보완하고자 `go-back-N 프로토콜`과 `Selective Repeat 알고리즘`이 등장한다.

### go-back-N

일정 크기만큼의 패킷을 한 번에 보내는 방식으로, 이 일정 크기를 `윈도우(window size)`라고 한다. 이때도 윈도우를 잘 받게 되면 피드백이 오는데, 이때의 ACK 피드백은 축적된 형태, 즉 Cumulative ACK가 된다. 

- ACK11: #11까지 패킷을 잘 받았음
- 수신자는 정상적으로 받지 못한 패킷이 있으면 정상적으로 받은 마지막 패킷의 ACK를 보낸다.
    - 패킷 1, 2, 3, 4, 5를 한 번에 전송했는데 수신자가 3을 못 받았으면 수신자는 3을 받을 때까지 ACK2를 보낸다.
- 전송자는 특정 ACK가 반복적으로 오면 그 다음 시퀀스 넘버의 패킷을 재전송한다.
    - 전송자는 그에 맞춰 #3 패킷를 보낸다.

전송자는 전송한 패킷 중 ACK를 받지 않은 가장 최신 패킷에 대해 타이머를 계산한다. 

- 만약 타임아웃이 발생하면, 같은 윈도우 내의 모든 ACK가 없는 패킷에 대해 재전송한다.
- 만약 ACK를 받으면, 그 다음 ACK를 받지 않은 가장 최신 패킷에 대해 타이머를 계산하고 반복한다.

이 방식의 경우 큰 문제가 하나 있다. 문제가 없는 패킷들도 같은 윈도우에 있었다는 이유로 재전송되는 이유가 비일비재하다는 점이다. 이런 점을 줄이려면 문제가 되는 패킷만 재전송하는 것이 좋을 것이다.

### Selective Repeat

수신자는 정상적으로 도착한 패킷에 대해 ACK를 보내고, 중간에 유실된 패킷이 있더라도 그 다음 패킷들을 버퍼에 잠시 보관하는 방식이다. 전송자는 ACK가 오지 않은 패킷만 재전송한다.

1. 수신자는 전송되는 패킷을 정상적으로 받아서 상위 계층으로 보내고 ACK를 보낸다.
2. 전송자는 ACK를 받고 window를 한 칸 옆으로 밀고 다음 패킷을 전송한다.
3. 전송자가 보낸 패킷 하나가 중간에 유실되었다.
4. 수신자는 그 다음부터 전송되는 패킷을 버퍼에 저장한다. 일단 패킷을 상위 계층으로 보내지는 않고 ACK만 보낸다.
5. 그사이에 유실된 패킷이 타임아웃 되면, 전송자는 유실된 패킷만 재전송한다.
6. 수신자는 정상적으로 패킷을 받으면 ACK를 반환한다.
7. 버퍼에 있던 그 이후의 패킷들과 함께 상위 계층으로 올려보낸다.

다만 이런 방식은 시퀀스 넘버가 충분하지 못하면 문제가 발생할 수 있다.

- 만약 시퀀스 넘버가 0, 1, 2, 3이라고 하고, 앞에 세 패킷을 잘 받았다고 하자. 근데 ACK가 모두 유실되었다면?
    
    → 이 경우 전송자는 ACK를 받지 못했으므로 다시 0, 1, 2를 보낸다. 근데 수신자는 이미 이전 패킷을 다 잘 받은 상태에서 새로운 0, 1, 2 패킷을 받았다고 생각하게 된다.
    

또한 패킷 유실이 발생하는 경우에도 문제가 생긴다.

- 이전 패킷이 모두 정상 전달되어 ACK를 받는다. 그 사이에 window가 바뀌고 새로운 패킷을 보낸다.
- 근데 그 사이에 보낸 패킷이 유실되었는데, 이전에 정상 전달된 ACK를 받으면서 윈도우가 계속 밀린다. 그러면서 시퀀스 넘버가 다시 그 지점으로 돌아오면 어떻게 될까?

두 가지 모두 언뜻 보기엔 시퀀스 넘버가 너무 작기 때문에 생기는 것으로 보이지만, 그렇다고 시퀀스 넘버를 무작정 늘리면 패킷에서 시퀀스 넘버가 차지하는 용량이 많아지므로 무작정 늘릴 수는 없다. 그래서 가장 적절하게 대처 가능한 시퀀스 넘버는 `윈도우 크기 * 2`가 된다.