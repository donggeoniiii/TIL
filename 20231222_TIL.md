# 20231222_TIL - JVMì˜ Runtime Data Area

## ì•Œê³ ë¦¬ì¦˜ í’€ì´

### B10026. ì ë¡ìƒ‰ì•½ ğŸ¥‡V

- ì•„ì´ë””ì–´
    
    ```jsx
    ë°©ë¬¸ì²´í¬ë¥¼ í•  ë•Œ êµ¬ë¶„ì„ ë‚˜ëˆ„ì–´ì•¼ í•œë‹¤
    
    1) ì •ìƒì¸: êµ¬ì—­ì˜ ìƒ‰ê¹”ê³¼ ë‹¤ë¥¸ ìƒ‰ì´ë©´ ë¬´ì¡°ê±´ íŒ¨ìŠ¤
    2) ì ë¡ìƒ‰ì•½: ë¹¨ê°• ì´ˆë¡ì„ ê°™ì€ ìƒ‰ ì·¨ê¸‰ ex) ë¹¨/ì´ˆ ì¼ ë•Œ íŒŒë‘ íŒ¨ìŠ¤ 
    
    main (){
    	init(); // ì…ë ¥ ë° ì´ˆê¸°í™”
    	simulationNormal(); // ì •ìƒì¸ êµ¬ì—­ì„¸ê¸°
    	simulationAbnormal(); // ì ë¡ìƒ‰ì•½ êµ¬ì—­ì„¸ê¸°
    	answer(); // ì¶œë ¥
    }
    ```
    
- ì½”ë“œ
    
    ```java
    package baekjoon;
    // ì ë¡ìƒ‰ì•½
    
    import java.io.BufferedReader;
    import java.io.IOException;
    import java.io.InputStreamReader;
    import java.util.LinkedList;
    import java.util.Queue;
    
    public class BOJ10026_ì ë¡ìƒ‰ì•½ {
    	// ê·¸ë¦¬ë“œì˜ í¬ê¸°
    	static int n;
    
    	// ê·¸ë¦¬ë“œ ë°°ì—´
    	static char[][] grid;
    
    	// ì •ìƒì¸ì˜ ë°©ë¬¸ë°°ì—´
    	static boolean[][] visitedNormal;
    
    	// ì ë¡ìƒ‰ì•½ì¸ ì‚¬ëŒì˜ ë°©ë¬¸ë°°ì—´
    	static boolean[][] visitedAbnormal;
    
    	// bfsë¥¼ ìœ„í•œ ë¸íƒ€ë°°ì—´
    	static int[] dr = {-1, 1, 0, 0};
    	static int[] dc = {0, 0, -1, 1};
    
    	// ê²°ê³¼
    	static int resultNormal, resultAbnormal;
    
    	public static void main(String[] args) throws IOException {
    		init();
    		simulationNormal();
    		simulationAbnormal();
    		answer();
    	}
    
    	private static void init() throws IOException {
    		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    
    		n = Integer.parseInt(br.readLine());
    
    		grid = new char[n][n];
    
    		for (int r = 0; r < n; r++) {
    			String line = br.readLine();
    			for (int c = 0; c < n; c++) {
    				grid[r][c] = line.charAt(c);
    			}
    		}
    	}
    
    	private static void simulationNormal() {
    		visitedNormal = new boolean[n][n];
    
    		// ì„œë¡œ ë‹¤ë¥¸ êµ¬ì—­ì˜ ìˆ˜
    		resultNormal = 0;
    
    		for (int r = 0; r < n; r++) {
    			for (int c = 0; c < n; c++) {
    				// ì²˜ìŒ ë³´ëŠ” êµ¬ì—­ì´ë©´ bfsë¡œ í•´ë‹¹í•˜ëŠ” ë²”ìœ„ ë°©ë¬¸ì²´í¬, êµ¬ì—­ +1
    				if (!visitedNormal[r][c]){
    					resultNormal++;
    					bfsNormal(r, c);
    				}
    			}
    		}
    	}
    
    	private static void bfsNormal(int sr, int sc) {
    		// bfsë¥¼ ìœ„í•œ queue
    		Queue<int[]> queue = new LinkedList<>();
    
    		// ì‹œì‘ì  ì…ë ¥, ë°©ë¬¸ì²´í¬
    		queue.offer(new int[] {sr, sc});
    		visitedNormal[sr][sc] = true;
    
    		// ë” ì´ì–´ì§€ëŠ” ì§€ì ì´ ì—†ì„ ë•Œê¹Œì§€
    		while (!queue.isEmpty()){
    			// ë‹¤ìŒ ë°©ë¬¸ì§€ì 
    			int[] cur = queue.poll();
    			int cr = cur[0];
    			int cc = cur[1];
    
    			for (int dt = 0; dt < 4; dt++) {
    				int nr = cr + dr[dt];
    				int nc = cc + dc[dt];
    
    				// out of index
    				if (outOfIndex(nr, nc)){
    					continue;
    				}
    
    				// ë‹¤ë¥¸ìƒ‰ì´ë©´ ì œì™¸
    				if (grid[nr][nc] != grid[sr][sc]){
    					continue;
    				}
    
    				// ë°©ë¬¸í–ˆìœ¼ë©´ ì œì™¸
    				if (visitedNormal[nr][nc]){
    					continue;
    				}
    
    				// ë°©ë¬¸í•˜ì§€ ì•Šì€ ê°™ì€ ìƒ‰ê¹” ì§€ì ì— ëŒ€í•´ì„œ ë°©ë¬¸ ì²˜ë¦¬í•˜ê³  queueì— ì¶”ê°€
    				visitedNormal[nr][nc] = true;
    				queue.offer(new int[] {nr, nc});
    			}
    		}
    	}
    
    	private static void simulationAbnormal() {
    		visitedAbnormal = new boolean[n][n];
    
    		// ì„œë¡œ ë‹¤ë¥¸ êµ¬ì—­ì˜ ìˆ˜
    		resultAbnormal = 0;
    
    		for (int r = 0; r < n; r++) {
    			for (int c = 0; c < n; c++) {
    				// ì²˜ìŒ ë³´ëŠ” êµ¬ì—­ì´ë©´ bfsë¡œ í•´ë‹¹í•˜ëŠ” ë²”ìœ„ ë°©ë¬¸ì²´í¬, êµ¬ì—­ +1
    				if (!visitedAbnormal[r][c]){
    					resultAbnormal++;
    					bfsAbnormal(r, c);
    				}
    			}
    		}
    	}
    
    	private static void bfsAbnormal(int sr, int sc) {
    		// bfsë¥¼ ìœ„í•œ queue
    		Queue<int[]> queue = new LinkedList<>();
    
    		// ì‹œì‘ì  ì…ë ¥, ë°©ë¬¸ì²´í¬
    		queue.offer(new int[] {sr, sc});
    		visitedAbnormal[sr][sc] = true;
    
    		// ë” ì´ì–´ì§€ëŠ” ì§€ì ì´ ì—†ì„ ë•Œê¹Œì§€
    		while (!queue.isEmpty()){
    			// ë‹¤ìŒ ë°©ë¬¸ì§€ì 
    			int[] cur = queue.poll();
    			int cr = cur[0];
    			int cc = cur[1];
    
    			// ë°©ë¬¸ì§€ì ì˜ ìƒ‰ê¹”
    			char curColor = grid[cr][cc];
    
    			for (int dt = 0; dt < 4; dt++) {
    				int nr = cr + dr[dt];
    				int nc = cc + dc[dt];
    
    				// out of index
    				if (outOfIndex(nr, nc)){
    					continue;
    				}
    
    				// ê¸°ì¤€ìƒ‰ì´ íŒŒë€ìƒ‰ì¸ë° íŒŒë€ìƒ‰ì´ ì•„ë‹˜ or ê¸°ì¤€ìƒ‰ì´ íŒŒë€ìƒ‰ì´ ì•„ë‹Œë° íŒŒë€ìƒ‰ì´ë©´ ì œì™¸
    				if ((curColor != 'B' && grid[nr][nc] == 'B')
    					|| (curColor == 'B' && grid[nr][nc] != 'B')) {
    					continue;
    				}
    
    				// ë°©ë¬¸í–ˆìœ¼ë©´ ì œì™¸
    				if (visitedAbnormal[nr][nc]){
    					continue;
    				}
    
    				// ë°©ë¬¸í•˜ì§€ ì•Šì€ ê°™ì€ ìƒ‰ê¹” ì§€ì ì— ëŒ€í•´ì„œ ë°©ë¬¸ ì²˜ë¦¬í•˜ê³  queueì— ì¶”ê°€
    				visitedAbnormal[nr][nc] = true;
    				queue.offer(new int[] {nr, nc});
    			}
    		}
    	}
    
    	private static boolean outOfIndex(int nr, int nc) {
    		return nr < 0 || nc < 0 || nr >= n || nc >= n;
    	}
    
    	private static void answer() {
    		System.out.println(resultNormal + " " + resultAbnormal);
    	}
    }
    ```
    
- ëŠë‚€ ì 
    - ë©”ì†Œë“œë¡œ êµ¬ë¶„í•˜ëŠ” í’€ì´ì— ì ì‘ì„ ì˜ í•œ ê²ƒ ê°™ë‹¤. ì˜ˆì „ì²˜ëŸ¼ êµ¬í˜„ì—ì„œ ì‹¤ìˆ˜ ì—†ì´ ë§¤ë„ëŸ½ê²Œ í’€ì—ˆë‹¤. ê°œì¸ì ìœ¼ë¡œ ì¡°ê±´ì„ ë”°ì§ˆê²Œ ë§ì§€ ì•Šì•„ì„œ í¸í–ˆë‹¤.

## Java(3)

### JVMì˜ ë©”ëª¨ë¦¬ êµ¬ì¡°

- Stack
    
    `í´ë˜ìŠ¤ ë‚´ì˜ ë©”ì†Œë“œì—ì„œ ì‚¬ìš©ë˜ëŠ” ì •ë³´`ë“¤ì´ `LIFO ë°©ì‹`ìœ¼ë¡œ ì €ì¥ë˜ëŠ” ê³µê°„ì´ë‹¤. 
    ë©”ì†Œë“œ í˜¸ì¶œë§ˆë‹¤ `ìŠ¤íƒ í”„ë ˆì„`ì´ë¼ëŠ” ë©”ì†Œë“œë§Œì˜ ê³µê°„ì„ ìƒì„±í•œë‹¤. ê·¸ ì•ˆì— `ë§¤ê°œë³€ìˆ˜, ì§€ì—­ë³€ìˆ˜, ë¦¬í„´ê°’ì„ ì €ì¥`í•˜ê³  ì‹¤í–‰ì´ ì™„ë£Œë˜ë©´ ì œê±°ëœë‹¤. ì„ì‹œ ì €ì¥ê³µê°„ì˜ ëŠë‚Œ.
    
- Method
    
    `í´ë˜ìŠ¤`ì™€ `ì „ì—­ë³€ìˆ˜(static), ë©”ì†Œë“œ, ìƒìˆ˜(final)`ë“¤ì˜ ê°’ì´ ì €ì¥ëœë‹¤. 
    
- Heap
    
    `new` ëª…ë ¹ì–´ë¡œ ìƒì„±ëœ `ì¸ìŠ¤í„´ìŠ¤`, `ë°°ì—´` ë“±ì˜ `ì°¸ì¡°í˜• ë³€ìˆ˜` ì •ë³´ê°€ ì €ì¥ëœë‹¤. method ì˜ì—­ì— ì˜¬ë¼ì˜¨ í´ë˜ìŠ¤ë§Œ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë§Œë“¤ ìˆ˜ ìˆë‹¤. GCê°€ ê´€ë¦¬í•˜ëŠ” ì˜ì—­ì´ë‹¤.
    
    stackì€ heap ì˜ì—­ì˜ ì¸ìŠ¤í„´ìŠ¤ì™€ ë³€ìˆ˜ ì •ë³´ë¥¼ `ì£¼ì†Œê°’`ì˜ í˜•íƒœë¡œ ê°–ê³  ì°¸ì¡°í•´ì„œ í™œìš©í•œë‹¤. 
    
    â†’ ì´ ë•Œë¬¸ì— ë°°ì—´ì„ `System.out.println()`ì„ í•˜ê²Œ ë˜ë©´ ì£¼ì†Œê°’ì´ ë‚˜ì˜¤ê³ , `Arrays.toString()` ë©”ì†Œë“œë¥¼ í†µí•´ ì •ë³´ë¥¼ String í˜•íƒœë¡œ ë°”ê¾¸ì–´ì„œ ê°€ì ¸ì˜¤ê³  ì´ë¥¼ ì¶œë ¥í•´ì•¼ ë°°ì—´ì˜ ì •ë³´ë¥¼ ë³¼ ìˆ˜ ìˆë‹¤.
    
- PC Register
    
    ì“°ë ˆë“œ ì‹œì‘ì‹œ í•˜ë‚˜ì”© ìƒì„±ë˜ë©°, ìˆ˜í–‰ ì¤‘ì¸ JVM ëª…ë ¹ì˜ ì£¼ì†Œë¥¼ ê°–ëŠ”ë‹¤.
    
- Native Method Stack
    
    ìë°” ì™¸ ì–¸ì–´ë¡œ ì‘ì„±ëœ ë©”ì†Œë“œë¥¼ ìœ„í•œ ë©”ëª¨ë¦¬ ì˜ì—­. ë°©ì‹ì€ stackê³¼ ë™ì¼í•˜ë‹¤.
    

```java
public class ScheduleService { // methodì— ì €ì¥
		public void createSchedule(ScheduleCreateRequest request) {
				// ì •ë³´ ìì²´ëŠ” method, ì‹¤í–‰ ê²°ê³¼ëŠ” stackì— ì €ì¥
				// ë©”ì†Œë“œ ì‹¤í–‰ ì¤‘ ìƒì„±í•˜ëŠ” ì¸ìŠ¤í„´ìŠ¤ê°€ ìˆë‹¤ë©´ heapì— ì˜¬ë¼ê°(GCê°€ ì´í›„ ì•Œì•„ì„œ ê´€ë¦¬)
		}
}
```